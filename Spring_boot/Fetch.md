## Fetch
### EAGER
* 바로 가져옴
* OneToOne
* ManyToOne

-> One으로 끝나는 경우 fetch에서 eager이 기본값이 된다.
### LAZY
* 필요할 때 가져옴
* OneToMany
* ManyToMany

-> Many로 끝나는 경우 fetch에서 lazy가 기본값이 된다.

### 기본값이 저런 식으로 정해진 이유
one으로 끝나는 건 그것과 연관된 데이터가 하나의 행만 있다고 보장된다.
그렇기 때문에 하나의 행을 바로 더 가져온다고 해도 별 문제가 없다.
하지만 many로 여러 개의 데이터가 있다면 실제로 쓰지도 않는데 가져오는 경우 부하가 발생될 것이다.

따라서 성능 문제 발생을 줄이기 위해 위와 같은 식으로 설정하는 것이다.

### JPA N+1 문제
* 쿼리가 N개이면 N번의 쿼리가 더 발생하게 되는 문제

Fetch를 바로 해서 진행하는 경우 EAGER로 하건, LAZY로 하건 selet를 따로 진행하게 된다. 따라서 이전에 조회한 데이터를 기준으로 새로운 데이터를 가져올 때에 그 데이터들로 검색을 하게 되어 N+1문제가 발생하게 되는 것이다.

예를 들어 사람 / 손 에 대해 검색하게 되는 경우
* 사람 검색
    * EAGER의 경우
        * 사람의 손을 바로 모두 검색한다.
            * 사람N명에 대해 검색 후 바로 사람마다 가진 손을 검색함
    * LAZY의 경우
        * 사람의 손을 찾아야 할 때 검색한다.
            * 사람N명 검색 후 오른손을 찾으려 하면 그 때에 또 전체에 따른 손을 검색함

이를 해결하기 위해 존재하는 것이 바로 Fetch Join이나 EntityGraph이다.
### Join Fetch
사실 Join Fetch는 JPA에서 제공해주지는 않는다.
그냥 사람이 직접 쿼리를 짜서 진행한다.
JPQL을 사용하여 join fetch를 진행하면 INNER JOIN으로 진행되어 N+1문제를 해결할 수 있다.

### EntityGraph
 <pre>@EntityGraph(attributePaths = { "받아올필드명" }) </pre>
 이렇게 하면 쿼리 수행시 Eager조회를 통해 바로 받아올 필드명을 조회해 온다.
 이건 OUTER JOIN으로 진행된다.
