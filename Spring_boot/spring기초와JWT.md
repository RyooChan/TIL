# Spring

## Spring Framework
스프링은 오픈소스 경량급 애플리케이션 프레임워크이다.

* Framework
    * 프로그램의 구조가 정리되어 있는 것.
    * 디자인/아키텍쳐 등에 제약을 주는 것이다.
        * 표준화를 시킬 수 있다.
            * 그래서 관리하기 쉽고, 예측이 가능해 진다.
* 경량급 프레임워크
    * 기존 EJB는 무거운 프레임워크였는데, Spring은 경량급 프레임워크이다.
* 엔터프라이즈 개발을 편하게 한다.
    * 개발자가 복잡하고 실수하기 쉬운 Low Level에 많이 신경 쓰지 않으면서 Bysiness Logic 개발에 전념할 수 있도록 해 준다.

### 특징
* 스프링 코어
1. 컨테이너 역할
Spring 컨테이너는 Java객체의 Life Cycle을 관리하며, Spring컨테이너로부터 필요한 객체를 가져와 사용할 수 있다.
2. DI지원(Dependency Injection)
개발자가 직접 할 필요 없이 설정 파일이나, 어노테이션을 통해 객체 간이 의존관계를 설정할 수 있도록 해 준다.
3. AOP 지원(Aspect Oriented programming)
기존 객체지향 프로그래밍을 보완해 주는 프로그래밍 기법인데, 이걸 Spring에서 받아들여서 Spring AOP라는 이름으로 지원해 준다.
스프링은 트랜잭션이나 로깅, 보안처럼 공통적으로 필요로 하는 모듈들을 실제 핵심 모듈에서 분리해서 적용할 수 있다.
4. POJO지원(plain old java object)
spring에서 사용되는 모든 객체들은 POJO라고 불리는 단순한 자바 객체이다.
어떤 것도 상속받지 않고, 어떤 것도 제약이 없는 단순한 자바 클래스로 만들 수 있다.
확장성도 좋아진다.
5. 트랜잭션 처리를 위한 일관된 방법을 지원
앤터프라이즈급 어플리케이션은 주로 데이터를 다루는데 이 무결성이 중요하다.
그래서 서비스, 서비스 단위별로 데이터 훼손이 없어야 한다.
그럴 때에 사용되는 것이 트랜잭션인데, 트랜잭션이 잘못 사용되는 경우 무결성이 깨질 수 있다.
그런 트랜잭션 처리를 일관되게, 쉽게, 선언적으로 사용할 수 있도록 도와준다.
6. 영속성과 관련된 다양한 API지원
기존 데이터, 새로운 데이터를 발생했을 때 그 데이터를 저장시켜주어야 한다. 이를 영속성이라 한다.
이거를 과거에는 관계형 DB에 저장했다면 최근에는 NoSql이나 다른 서비스 요청과 같은 외부 시스템과의 연동에 관한 내용을 별도의 spring project / module로 지원해 준다.

---

### spring5
미래의 스프링 기술이다.
핵심 : 비동기 기술이다.
기존에서도 멀티쓰레딩에서도 지원해 준다.
spring은 서블릿 위에서 만들어졌기 때문에 모든 서블릿을 지원해 준다.

근데 spring5는 리액티브 위의 기반이라 그걸 기반으로 지원한다.
리액터 라는 기술로 리액티브 기술을 지원해 준다.
기존 spring4까지 썼던 servlet Stack + reactive Stack을 모두 합쳐서 지원해 준다.

비동기 서비스는 최앞단 ~ 최뒷단까지 모든 것들을 비동기로 할 수 있게끔 해야 하는데, 그걸 지원해 준다. <- 그 기술이 리액터임.

---

* 스프링 부트
    * 스프링 프래임워크를 쉽게 사용할 수 있도록 해준다.
    * 미리 설정이 다 되어있는데 -> Convention over Configuration
        * 전통을 따른다.(Best Practice)
            * 스프링 커뮤니티에서 가장 많이 사용하고, 좋다고 평가받는 것들을 가져와서 쓰겠다.
    * 스프링 부트를 통해 개발하면 많은 것들이 미리 설정 되어있어서 이를 사용하면 빠르고 쉽게 개발할 수 있다.
    * 성능상에 저하가 있는건 아니다.
    * 생상성에서 많은 혜택이 있다.
    * 물론 최적화는 Spring으로 하는게 더 좋긴 하다.

* 기본으로 만들어주는 Application.java
    * SpringBootApplicatino
        * Configuration
        * ComponentScan
        * EnableAutoConfiguration
    * 이 소스를 실행하면 스프링 프로젝트로 만들어진 프로젝트를 실행 시켜줄 수 있다.

---

## REST
REST는 아키텍쳐 보다는 사실 규약이다.
근데 이게 보편화되어있고 표준으로 자리잡았다.

* 서비스
    * 어플리케이션들 끼리 혹은 노드끼리 각각의 데이터를 교환하고 서로 통신하는 것.
* 그 통신 규약은 http프로토콜을 사용한다.
    * 그게 웹 서비스이다.
        * 이 웹 서비스에의 표준화 작업이 이루어진다.
            * 그게 xml이라는 포멧을 통해 만든 공식 표준이 SOAP이다.
                * 근데 이걸 써보니까 좀 부족함이 있고 더 좋은 방식이 있다.
                    * 그 제안된 방식이 REST방식이다.
                        * 그래서 SOAP이라는 공식 표준보다는 사실상 표준인 REST방식이 보편적으로 사용된다.
* SOAP과 REST는 기본적으로 web플랫폼 위에서 이루어진다.


SOAP은 XML중시
REST는 JSON을 많이 쓴다. 여기서 XML을 쓰긴 하는데 JSON을 더 많이 쓴다.

HTTP Methods
![](https://i.imgur.com/uI4eFkq.png)

* RESTful 기반 웹 서비스
    * 웹 아키텍처가 웹의 본래 설계의 우수성을 활용하지 못하므로 웹의 장점을 최대한 활용할 수 있는 네트워크 기반의 아키텍처 제안

* SOAP
    * 동작과 프로세싱에 집중
* REST
    * 관심은 데이터 처리

---

* REST란?
Create - POST
Rest - GET
Update - PUT
Delete - DELETE와 같이 HTTP 4가지 메소드를 용도에 맞게 사용

* REST원리 및 원칙(제약조건)
    * 확장성 있는 웹 서비스를 위한 소프트웨어 아키텍처 적인 접근
    * Client - Server
    * Stateless (상태가 없어야 된다.)
        * 요청이 동일하다면 응답도 동일해야 한다.
        * 클라이언트의 상태를 서버에 저장하지 않음
    * Cacheable (상태가 없음으로서 Cacheable하게 된다)
        * 기존에 캐쉬가 남아있다면 같은 응답을 함으로서 서버에 부하가 없고 효율이 좋아진다.
    * Layered system
    * Code on demand (optional)
    * Uniform interface
        * REST의 코어인 리소스는 URI에 의해 식별됨
        * 데이터 구조는 강제하지 않음
            * 주로 XML이나 JSON

* Client-Server
    * View와 DATA를 분리하라.
    * server는 클라이언트에게 데이터만 응답하게 된다.
* Stateless
    * 서버가 상태를 가지고 있지 않아야 한다.
    * 요청 자체가 같다면, 응답도 같아야 한다.
    * Pure function
    * 서버에서 session을 제거하는 것이 stateless이다.
        * 따라서 이 때와는 인증 방식이 바뀐다.
            * Token방식 or 3자 승인 인증방식을 쓰게 된다.
* Cacheable
    * 캐쉬를 잘 활용할 수 있게 하는거다.
    * restful서비스를 잘 사용하면 cathe를 잘 사용할 수 있게 된다.
* Layered System
    * 인접한 구간끼리만 통신을 한다.
        * 클라이언트에서 요청해서 server까지의 요청 과정에 여러 노드가 존재하게 된다.
        * 그렇게 다양한 노드를 거쳐서 server로 가게 된다.
* Code on Demand(optional)
    * 최근에 잘 안쓰이다.
    * 서버에서 모든 것을 다 실행한다기보다는 서버에서 실행 코드를 클라이언트로 전송해서 그곳에서 일을 하도록 하는것이다.
* Uniform Interface
    * 리소스를 요청하는 것
    * URL주소만 있으면 클라이언트가 어떤 기술이든지 서버는 상관이 없다는 것이다.
    * 기술이나 플랫폼과 상관 없이 통일된 인터페이스 사용 가능
    * 4가지로 설명될 수 있다.
        * Resource Identifier
            * URL / URI를 요청의 endpoint로 쓰겠다.
        * Resource Representations
            * URL은 resource와 연결되어 있다.
            * 이 resource가 representation으로 변환된다.
                * 즉 하나의 url을 선택해도, 그 응답이 다를 수가 있다.
            * 똑같은 URL을 요청해도, 메소드(POST/GET/PUT/DELETE)에 따라 다른 응답을 얻어올 수 있다.
        * self-descriptive message & API
            * 상태가 저장되지 않아 요청을 할 때마다 서버 입장에서는 새로운 요청이 되는 것이다.
            * 그리고 내가 응답할 때도 마지막 응답이 되는 것이다.
            * 그렇기 때문에 처음 요청에 대한 응답이 되는 것처럼 충분히 많은 메시지를 응답해 주어야 한다.
            * 요청도 마찬가지로 처음 요청하는 것 처럼 충분한 정보를 가지고 요청해야 한다.
        * HATEOAS
            * Hypermedia As The Engine Of Application State
            * 서비스의 입장에서는 요청에 대해서 그 representation을 보내 주는데, HHTP응답에 다음 Action이나, 관계되는 리소스에 대한 HTTP Link를 함께 리턴시켜 주는 것이다.
                * 즉, 페이지 처리 리턴 시 전후 페이지에 대한 링크를 제공하거나, 연관 리소스에 대한 디테일한 링크를 표시시켜 주는 것이다.

---

### Spring-Web MVC에서의 RESTful 지원

@Controller
개발자가 코딩하는 코드에서 제일 먼저 클라이언트의 요청을 받아들이는 부분.
이 클래스를 컴포넌트로 만들어 준다.

---

Layered Architecture 특징
* 계층화 아키텍처
    * 효율적인 개발과 유지보수를 위해 계층화하여 개발
    * 대부분의 중 대규모 어플리케이션에서 적용
    * 각 레이어는 독립된 R&R을 가진
        * 프레젠테이션영역
            * 사용자와 상호작용
            * 사용자의 요청을 분석/응답
        * 비즈니스 영역
            * 기능을 수행
            * 트랜잭션 수행
        * 데이터 영역
            * 데이터의 저장과 조회를 담당
            * 주로 DB와 연동하여 작업

컴포넌트
스프링에서는 스프링 컨테이너 위에 로딩되는 객체
직접 객체를 생성한다거나 라이프사이클을 관리하지 않고 자동으로 manage된다.

* @Component
    * @Controller
        * presentation
    * @Service
        * Service
    * @Repository
        * persistence / DAO
@Autowired
Component간의 의존관계는 Autowired라는 annotation으로 적용한다.
    
JSON(javscript object notation)
    경량의 DATA-교환 형식
    javascript에서 객체를 만들 때 사용하는 표현식을 의미함
    JSON표현식은 사람과 기계 모두 이해하기 쉽고 용량이 작아 XML을 대체하여 데이터 전송 등에 많이 사용한다.
    특정 언어에 종속되지 않으며, 대부분의 프로그래밍 언어에서 JSON포맷의 데이터를 핸들링 할 수 있는 라이브러리를 제공하고 있음.\
    
JSON은 key-value형식의 쌍이다.
그렇게 java의 map과 비슷하기 때문에 java에서 map을 사용하면 자동으로 JSON형태로 만들어 줄 수 있다.
JSON은 key는 주로 String, key는 모든 타입을 사용 가능하다(List, 또다른 JSON형태 다 가능)
java에서 자동으로 JSON으로 변환되는건 Jackson라이브러리를 통해서 바뀐다

-- 

spring security

스프링 시큐리티란?
인증, 권한 관련 프레임워크
인증 : 이 요청에 대해 이 요청에 대한 허가를 주는 것
권한 : 이 요청이 모든 resource를 다 사용 가능할지
권한이 있는 요청에만 허락해줌

* JWT
    * JSON Web Token
    * JWT토큰 형태로 많이 사용된다.

주요 인증 방식
* 로그인 기반 인증(토근 기반 인증)
    * Credential-based authenticaion
* 인증정보를 다른 어플리케이션으로 전달
    * 제3자가 인증을 처리
    * OAuth2
* 2단계 인증
    * 1차 인증 후에 한번 더 인증하는거
* 하드웨어 인증
    * Hardware authentication

기존 세션 기반 인증 시스템 문제점
* 세션
    * 유저가 인증할 때 이 기록을 서버에 저장
    * 메모리에 혹은 DB시스템에 저장
    * **유저의 수(동시접속)가 많으면 서버나 DB에 부하가 간다.**
* 확장성
    * 클러스터링 구성 시 세션 정보도 같이 공유해야 하ㅓㅁ
    * 서버 구성이 복잡해짐
* CORS
    * 쿠키를 여러 도메인에서 관리하는 것이 번거로움
* 여기서 토큰을 사용하면 이런 문제를 해결 가능

* 토큰
    * 작동원리
        * 유저가 아이디와 비밀번호로 로그인 수행
        * 서버측에서 해당 정보 검증
        * 계정정보가 정확하다면 서버측에서 유저에서 signed토큰을 발급
        * 클라이언트에서는 토큰을 저장해 두고 요청마다 토큰을 서버에 함께 전달
        * 서버에서 토큰을 검증하고 요청에 응답
            * 토큰 위조를 막기 위해 양측에 토큰을 저장해 두고 검증함
            * 그리고 토큰 만료 기간도 활용한다.
* 토큰 기반 인증 시스템 - 토큰의 장점
    * 무상태(Stateless)이며 확장성(Scalability)이 있음
    * 보안성
        * 쿠키를 사용하지 않음
        * 토큰환경에서도 취약점은 존재한다.
    * Extensibility
        * 서버 확장이 아닌 기능 확장 가능
        * 토큰에 여러가지 데이터를 담을 수 있다.
        * 토큰의 바디 부분에 여러 데이터를 담아서 가능하다.
    * 여러 플랫폼 및 도메인
        * CORS
            * 아무 도메인에서나 토큰이 유효하면 요청이 정상적으로 처리된다.
    * 웹 표준 기반
        * JWT
            * 토큰기반 인증 시스템 구현체(RFC7519)
* JWT특징
    * 기본적으로 String이다.
        * 그렇기 때문에 웹 표준으로 적합하여 여러 프로그래밍 언어에서 지원 가능
    * Self-contained
        * 필요한 모든 정보를 자체적으로 가지고 있다.
        * 효율적인 사용 가능
    * HTTP헤더, URL파라미터로 전달 가능
    * 회원 인증 / 정보 교환으로 사용 가능
* JWT구조
    * [ . ] 을 구분자로 3가지 문자열로 구성된다.
    * 헤더 / 내용 / 서명 
    * aaaa.bbbbb.ccccc
        * 헤더
            * typ : 토큰의 타입 지정
            * alg : 해싱 알고리즘 지정
        * 정보
            * 토큰에 담을 정보가 포함(클레임이라고 함, name/value쌍으로 구성)
            * 클레임은 3분류로 나뉘다.
                * 등록(registered)클레임
                    * iss, sub, aud, exp, nbf, sat, jti
                * 공개(public)클레임
                    * 충돌 방지 이름이 필요(주로 URI형식으로 네이밍)
                * 비공개(private)클레임
                    * 클라이언트와 서버 간의 협의 하에 사용되는 클레임 이름들
        * 서명
            * 헤더의 인코딩 값과 정보의 인코딩 값을 합친 후 주어진 비밀키로 해쉬하여 생성
