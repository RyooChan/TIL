## 기본적 구조 요소

- 기본적으로 폰 노이만 구조, 하버드 구조 이렇게 있는데 둘의 차이는 메모리 배열뿐이다.
- 폰 노이만 구조는 메모리 버스와 주소 버스가 하나뿐이다.
- 폰 노이만 구조가 약간 더 느리지만 하버드 구조는 두번째 메모리 처리를 위한 버스가 더 필요하다.

### 프로세서 코어

- 위의 두 구조는 모두 CPU가 하나뿐이다.
- 단일 CPU보다 성능을 높이기 위해 멀티프로세서가 도입됐는데 병렬화에서 문제가 있었다.
- 예전에는 CPU라는거를 요즘은 프로세스 코어라고 하고, 이거를 여러개 쓰는거를 멀티코어라고 한다.

### 마이크로프로세서와 마이크로컴퓨터

- 마이크로프로세서
    - 메모리와 I/O가 프로세서 코어와 같은 패키지에 들어 있지 않음
- 마이크로컴퓨터
    - 모든 요소를 한 칩 안에 패키징
- 일단은 메모리가 차지하는 영역이 꽤 크기 때문에 마이크로프로세서보다 마이크로컴퓨터가 덜 강력함.
- 요약하면 마이크로프로세서는 보통 큰 시스템에 들어가는 부품이고 마이크로컴퓨터는 말 그대로 작은 컴퓨터이다.
- 추가로 SoC라는게 있는데 더 복잡한 마이크로컴퓨터를 의미한다.

### 프로시저, 서브루틴, 함수

- 일단 여기서는 세개가 같은 의미
- 간단하게 말하면 그냥 똑같은거 여러번 쓰기 귀찮으니 한번 해놓고 쓰는 메서드같은거
- 이거는 그냥 쓴다고 되는게 아니고(java, js 등으로)
    - 그게 어떤 식으로 동작을 하기 때문에 되는것이다. -> 이 때 쓰는게 명령어 집합이다.

### 스택

- 함수는 다른 함수를 호출할수도, 자기 자신을 호출할수도 있다.
- 자기 자신을 호출하는 재귀같은 경우를 생각하면
    - 재귀 함수가 제대로 작동하기 위해서는 반환 주소를 여러개 저장할 수 있어야 한다.
    - 그리고 함수에서 호출 지점으로 반환할 때 저장된 주소 중 어떤 주소를 사용할지 결정할 수 있어야 한다.
    - DFS, BFS 생각하면 편하다.
    - 암튼 이럴 때에 주소를 쌓아두고 없애는데 이런거를 스택이라고 한다.
        - 어떤 함수가 불렸을때 어디서 어떻게 불렸고 그 결과가 어디서 쓰이는지 알아야하잖어

### 인터럽트

- 동작 중에 잠깐 중단시켜서 주의해야할 내용을 바로 대응하는것
    - 요거는 이제 지금 실행되고 있는 명령어는 끝까지 실행하고, 프로세서가 그 이후로 실행중 프로셋
- 고려해야 할 점이 있는데
    - 응답 시간 -> 너무 오랜 시간을 소요하면 안된다.
    - 현재 상태 저장 -> 인터럽트 처리 후 돌아올
        - 이 상태를 스택에 저장한다.

### 상대 주소 지정

- 여러 프로그램을 동시에 실행하려면?
- 각 프로그램 전환을 위한 관리자 프로그램이 필요한데, 이거를 커널이라고 한다.
- OS와 OS가 관리하는 프로그램을 구분하기 위해 OS를 시스템 프로그램, 다른 모든 프로그램을 사용자 프로그램이나 프로세스라고 부른다.
- 보통
    - 사용자프로그램 읽기 -> 상태 복원 -> 사용자 프로그램 실행 -> 타이머 인터럽트 -> 사용자 프로그램 중단 -> 상태 저장
        - 요거를 반복한다.
- 사용자 프로그램의 실행 시간을 조절하는 스케줄링 기법을 시분할이라고 부른다.
    - 시간을 정해진 간격으로 나누고, 정해진 시간 간격 동안 사용자 프로그램을 실행한다.
- 이 사용자 프로그램 상태나 문맥(컨텍스트)는 레지스터 상태와 프로그램이 사용중인 메모리의 상태를 뜻한다.
    - 메모리에는 스택도 포함!
- 이거는 좋은데 너무 느리다.
    - 프로그램을 메모리로 불러들이려면 시간이 걸림.
    - 그래서 각 프로그램에 각기 다른 공간을 허용할 수 있으면 훨씬 더 빠르게 시분할 실행이 가능하다.
        - 사용자 프로그램이 하나씩 차례로 메모리에 올라간다.
            - 주소 지정 모드 설명할 때 컴퓨터는 절대 주소 지정을 사용
                - 이거는 즉 명령어 주소가 특정 메모리 주소를 가리킨다는 뜻
    - 인덱스 레지스터를 추가해서 문제 해결
        - 인덱스 레지스터 사용하면 인덱스 레지스터의 값을 명령어에 들어 있는 주소와 더해서 유효 주소를 계산한다.
        - 사용자주소 : 1000번지 , 인덱스 레지스터 : 2000 -> OS는 이 프로그램을 3000번지에서 실행
    - 혹은 상대 주소 지정으로 해결
        - 명령어의 주소를 기준으로 하는 상대적 주소로 해석
        - 명령어가 들어있는 위치로부터 얼마나 떨어져있는지 이런거
            - 이거를 직접 계산하는거는 진짜 힘들지만 요즘은 프로그래밍 언어 도구들이 알아서 해줌

### 메모리 관리 장치

- 동시 작업은 계속해서 백그라운드에서 실행돼야해서 멀티태스킹이 필수다.
- 인덱스 레지스터랑 상대 주소 지정이 있으면 멀티태스킹에 도움이 되지만 이거만으로는 충분하지 않다.
    - 버그가 있으면 사용자 프로그램 1이 차지한 메모리를 덮어쓰거나 심지어 OS의 메모리를 덮어쓴다면
    - 의도적으로 시스템에 실행 중인 다른 사람의프로그램을 들여다보거나 변경하는 프로그램을 작성한다면
- 아예 각 프로그램을 분리하는게 좋은데, 그걸 위해 메모리 관리 장치가 들어있다.
- MMU 시스템은 가상주소와 물리주소를 구분한다.
    - 프로그램은 가상주소로 작성되고, MMU는 가상주소를 물리주소로 변환해준다.
- MMU랑 인덱스레지스터 차이
    - MMU의 가상 주소 범위는 물리적 메모리 주소보다 큰 경우가 많다.
        - MMU는 가상 메모리 주소를 두 부분으로 나눈다.
            - 주소 하위(LSB쪽) 부분은 물리적 주소 범위와 같다.
            - 주소 상위(MSB쪽) 부분은 페이지 테이블이라는 RAM영역을 통해 주소를 변환한다.
- 프로그램 입장에서는 가상 메모리가 연속적인 것처럼 보이지만 실제 물리 메모리상의위치는 연속적이지 않아도 된다. -> 바뀌는것도 가능

### 가상 메모리

- OS는 MMU를 통해 가상 메모리 제공
- 요청받은 메모리가 사용가능 메모리보다 크면 안쓰는걸 옮기고 사용
    - 참고로 이런 스와핑이 일어나면 시스템 성능이 저하된다. 그래도 느리더라도 프로그램 실행이라도 하는게 나음ㅇㅇ

### 시스템 공간과 사용자 공간

- 각자 프로세스마다 메모리 주소 공간 제공 -> 자기가 유일하게 실행되는거라고 생각하게
    - 인터럽트같은거 쓰면 근데 격리 안됨
    - 이게 시스템모드인지/사용자모드인지 결정하는 비트 필요
        - I/O처리 등의 명령어는 특권명령어라 시스템 모드에서만 실행가능
        - 트랩이나 시스템콜같은걸 통해 요청 가능
            - 이렇게 하면 운영체제 보호 가능 + 운영체제가 프로그램에 대한 자원 할당만 전적으로 제어 가능 등

### 메모리 계층과 성능

- 캐시!!

### 코프로세서

- 비서마냥 몇가지 연산을 위임받아 처리. 
- 직접 메모리 접근 등

### 메모리상 데이터 배치

- 메모리에는 명령어 뿐 아니라 데이터도 담는다.
    - 이때 데이터는 `static`이다.
    - 말하자면 프로그램 작성 때에 얼마나 많은 메모리가 필요한지 알고 있다는 것.
- 대부분의 프로그램은 동적 메모리를 다뤄야 하는데, 예를 들어 메시지 시스템은 저장해야 할 메시지 개수나 각 크기를 알 수 없고, 이런거는 정적 데이터 영역의 위 영역에 쌓이는데 이를 힙(heap)이라고 한다.
- 더 많은 데이터를 저장해야 하면 스택은 아래로, 힙은 위로 자라난다.

### 프로그램 실행

- 공유 라이브러리를 사용하는 동적 링크 방식 사용~

