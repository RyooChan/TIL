- 컴퓨터는 크게 3개로 나뉜다.
    - 메모리
    - 입/출력
    - CPU

## 메모리

- 조작할 비트들을 저장할 장소
- 각각 바이트를 저장하는 위치가 있고, 거기 주소가 부여된다.
    - 참고로 기본은 1비트이고 몇비트 컴퓨터인지에 따라 메모리의 덩어리가 달라진다.
    - 즉 32비트다 이러면 메모리가 4비트 덩어리로 구성된다.
        - 더 많은 데이터를 데이터 버스에 실을 수 있기 때문
- 데이터 버스에서 메모리의 위치가 어디로 갈지는 엔디안으로 확인한다.
    - 인텔은 0번 바이트가 가장 오른쪽 / 모토로라는 0번이 가장 왼쪽 이런식으로 엔디안을 염두에 둬야한다.

## 입력과 출력

- 외부랑 통신하기 위해 사용. 주변장치라고도 한다.

## 중앙 처리 장치

- 실제 계산을 처리하는 컴퓨터 부품
- 다양한 요소로 이루어진다.
    - 산술 논리장치(ALU : arithmetic logic unit)
        - CPU의 핵심 부품
        - 산술 계산, 불리언 대수 및 기타 연산을 수행하는 방법을 알고 있는 장치.
        - 피연산자와 연산 코드, 조건 코드를 통해 결과값을 내는것
    - 시프트
        - 왼쪽 시프트 : 어떤 숫자의 모든 비트를 왼쪽으로 1비트씩 옮기고 맨 왼쪽 비트는 버리고 가장 오른쪽 비트는 0
        - 오른쪽 시프트 : 어떤 숫자의 모든 비트를 오른쪽으로 1비트씩 옮기고 맨 오른쪽 비트는 버리고 가장 왼쪽 비트는 0
    - 실행 장치
        - 제어 장치로도 부르며 컴퓨터의 대장 역할을 한다.
        - ALU는 그 자체로는 유용하지 않고 누군가가 할 일을 알려줘야 한다.
        - 그거 하는게 실행장치
        - 하는 방법은 실행 장치에게 명령어 목록을 전달해서 얘가 명령어를 찾는것이다.
            - 명령어는 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴
            - 프로그램 카운터를 통해 메모리에서 명령어를 가져오는 위치를 알 수 있다.
                - 참조해서 들고옴
- 명령어 집합
    - 컴퓨터가 메모리에서 명령어를 찾음.
    - 명령어
        - 먼저 그냥 명령어를 명령코드, 두 피연산자, 결과 이렇게 4개로 나누면 너무 효율이 낮다.
        - DRAM 주소 지정 기법을 쓰면
            - 주소 확장 레지스터를 두고 별도의 명령어를 사용해 상위 주소(주소에서 MSB에 가까운 비트들) 지정
            - 이게 인텔에서 32비트 CPU를 이용해 4GB 이상 메모리에 접근할 때 사용한 방법이다.
            - 이거는 값을 설정하려면 시간이 더 들고 여러 번 레지스터를 설정해야 하는 단점이 있다.
            - 그래서 한번에 한 주소에만 접근 가능한 누산기가 있음
        - 주소 지정 모드
            - 누산기를 써도 주소가 충분하지 않다.
            - 누산기는 직접 주소 지정으로 사용할 주소가 명령어에 직접 들어가 있다.
            - 간접 주소 지정을 추가하면 더 많은 메모리 사용 가능
                - CPU명령어에 들어있는 값을 피연산자 주소로 해석하지 않고 피연산자 주소를 얻을 수 있는 메모리 위치를 가리키는 주소로 사용
        - 즉시 주소 지정 모드
            - 주소에 해당하는 비트를 그냥 값으로 간주
    - 조건 코드 명령어
        - 분기 명령어
            - 선택적 실행 분기
    - 최종 명령어 집합 구성
        - 그러면 이제 모드 / 명령코드 / 주소 이렇게 있음.

## 명령어 설계

- 명령어 레지스터
    - 컴퓨터는 명령어를 한번에 하나씩 수행하는게 아니다.
    - 먼저 명령어를 가져와야한다(이걸 페치라고 함)
    - 그 후에 이걸 어떻게 수행할지 고민해야 한다.
    - 명령어 실행을 위해서는 메모리에 접근해야 할 경우가 많은데 이 말은 다른 목적으로 메모리를 사용할 때 페치한 명령어에 편하게 접근할 수 있도록 저장할 다른 위치가 필요하다는 뜻이다.
    - CPU에 명령어 레지스터를 추가해 현재 실행 중인 메모리를 저장한다.
- 데이터 경로와 제어 신호
    - 메모리 주소 버스에 프로그램 카운터 값을 넣을 방법이나 메모리에 있는 데이터를 명령어 레지스터로 넣을 방법에 대한 고민 등..
- 데이터 흐름 제어
    - 입력 출력 흐름을 제어하는 장치인데
    - 페치
        - 간접적으로 주소를 메모리에서 가져오기 위해
        - address source를 명령어 레지스터로 지정.
        - 메모리 동작.
        - 간접 주소 레지스터 동작
    - 누산기에 잆는 값을 주소에 저장
        - address source를 간접 주소 레지스터로 설정
        - data bus enable 1 설정
        - 메모리 동작
        - 프로그램 카운터 증가
    - 이런 페치와 실행에는 여러 단계가 필요해서 단계 추적의 카운터가 필요하다.

## RISC, CISC 명령어 집합

- 컴퓨터 명령어가 복잡해지면서 제어 회로도 복잡해짐
- 근데 복잡한 명령어중 상당수는 거의 안쓰인다.
- 복잡한 명열어를 그냥 단순한 명령어를 조합해 처리하는건 어떨까?
    - 이거를 RISC라고 한다.
- 기존 설계대로 복잡한거 쓰는거는 CISC
- RISC
    - 중요한 특징은 적재-저장 구조이다.
        - 메모리와 레지스터를 오가는 명령어들과 레지스터 간 명령어로만 이뤄진 구조이다.
- CISC
    - Auto Increment, AUto Decrement 주소 지정 모드 이런거는 유용하게 쓰이는 느낌
    - 참고로 C언어는 B언어로부터 만들어졌는데 C부터 포인터 간접 주소 지정 추상화에서 B언어 자동증가 자동감소 기능이 잘 어울어짐

## GPU

- 그래픽처리장치
