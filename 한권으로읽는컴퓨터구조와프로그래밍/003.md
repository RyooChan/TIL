순차 논리란, 순서에서 비롯된 말이다.
즉 시간적으로 어떤 값 뒤에 오는 다른 값이라는 건데
그동안 배웠던 조합 논리는 입력의 현재 상태만을 다뤘다면 순차논리는 현재와 과거를 함께 고려한다.

## 시간 표현과 상태 기억

- 주기함수를 사용해 시간 측정
    - 예를 들어 지구의 자전이 주기함수임.
- 발진자
    - ![image](https://github.com/RyooChan/TIL/assets/53744363/5e4d7a43-9f01-42e7-a069-c604a1e1914c)
    - 요런 식으로 주기에 맞춰 피드백을 돌려주는거
    - 이게 정확하게 하려면 크리스탈을 활용하면 된다.
- 클록
    - 발진자를 통한 시간 측정
    - 참고로 이걸 통해 컴퓨터가 시간을 측정하기 때문에 오버클로킹하면 클록을 빠르게 공급 가능
- 래치
    - ![image](https://github.com/RyooChan/TIL/assets/53744363/8bf10215-5c0c-49d2-8eaf-a48e4b89e450)
    - OR게이트 출력을 입력에 묶는 피드백을 통해 정보 기억 가능
        - 요렇게 하면 입력이 들어온 다음부터는 무조건 1이 될것이다.
        - 이를 해결하기 위해 회로 재설정 과정이 요렇게
        - ![image](https://github.com/RyooChan/TIL/assets/53744363/81642c5a-e0f0-45bd-8ce2-63a6523d4b3d)
            - 여기서 reset위에 줄그어진거는 반전이라는 것이다.
            - 동작을 간단하게 말하자면 set1이 1이면 계속 1이다가 reset이 1이 들어오면 -> 반전연산에 의해 0으로 바뀌는(그때 set은 0이어야 한다)것.
        - ![image](https://github.com/RyooChan/TIL/assets/53744363/1c46d9c0-a163-4146-86b4-83bb02e1f123)
            - 요렇게 하면 대칭이라 set reset신호 지연 시간이 거의 비슷하다.
- 게이트가 있는 래치
    - 게이트가 있는 S-R 래치
        - ![image](https://github.com/RyooChan/TIL/assets/53744363/ee139587-8df6-4d83-83a8-911f009b3df3)
        - 이거 보면 gate의 반전이 거짓(1)이면 set, reset이 무엇이든 관계 없이 1로 출력이 유지된다.
    - 게이트가 있는 D래치
        - ![image](https://github.com/RyooChan/TIL/assets/53744363/a69b6b94-1b71-4c73-8321-da211bf11274)
        - ![image](https://github.com/RyooChan/TIL/assets/53744363/93f80dc6-206f-4e37-8000-5aa1404fc957)
        - 여기서는 gate의 반전이 거짓이면 D가 변해도 Q출력에 아무 변화가 없다.
        - 근데 이거 문제는 gate의 반전이 참(0)인 상태에서는 D의 변화가 그대로 출력에 나타난다는 점
            - 게이트가 열려 있는 동안에는 스스로의 상태를 바꾸지 않아야 하는데, -> 즉 게이트 여는 시간을 최소화해서 순간적으로 D의 상태에 맞춰 출력 상태를 변경할 수 있다면 좋음
- 플립플롭
    - 위에서 봤던 것처럼 데이터 변경으로 인해 잘못된 결과가 생길 수 있는 가능성을 최소화하는게 좋다.
    - 가장 많이 사용되는건 논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는것.
        - 이런걸 엣지(edge)라고 부른다.
            - 엣지를 시간에 대한 판정 기준이라고 생각할 수 있다.
    - 에지에 의해 데이터 변화가 촉발되는 래치를 플립플롭이라고 한다.
        - 뭔가 종류가 있는것같기는 한데, 그냥 얘의 역할은 어쨌든 이것이다.
        - 즉, 변화가 있을 때까지 데이터를 유지하다가, 변화가 생기면 이를 바로 캐치할 수 있는것

## 메모리 조직과 주소 지정

- 비트 기억에 플립플롭 유용하고, 레지스터는 여러 비트 저장
    - 그러면 많은 정보는?
- 주소를 부여한 레지스터를 쌓아서 하기
    - 여러개를 쌓아서 번호를 부여한다.
        - 주소 버스랑 데이터 버스를 통해 이를 찾아가기
            - 참고로 행과 열 주소를 멀티플렉싱하면 주소 라인의 수를 반으로 줄일 수 있다.
                - 여기서는 주소 저장을 위한 레지스터가 사용된다.

## 임의 접근 메모리

- 지금까지 살펴본거를 RAM(Random Access Memory : 임의 접근 메모리)이라고 한다.
- 정적램
    - 비싸지만 빠름.
    - 각 비트에 트랜지스터가 6개 들어간다.
    - 트랜지스터는 공간을 차지하기 때문에 SRAM은 수십억 ~ 수조 비트를 저장하기 좋은 선택은 아님
- 동적램
    - 커패시터라는 작은 버킷에 전자를 담고, 트랜지스터 하나만 사용해 뚜껑 닫기
        - 근데 이 버킷은 자주 새기 때문에 가끔 메모리 갱신이 필요하다.
    - 이거는 집적도가 높아서 큰 메모리 칩에 사용된다.
- 참고로 램은 모두 휘발성이다.

## 읽기 전용 메모리

- ROM(Read Only Memory)
- 참고로 읽기전용은 아니고, 한번밖에 못쓰는 메모리임.
- 이거는 비휘발성

## 블록 장치

- 디스크
    - 이거는 한번 지나간 데이터를 다시 읽으려면 다시 한바퀴 돌아야한다.

## 플래시 메모리와 SSD

- 플래시 메모리는 최근 나타난 EEPROM유형 매체
    - DRAM과 마찬가지로 버킷에 전자를 담는데, 버킷이 크고 더 잘 만들어져 있어 전자가 새지 않는다.
    - RAM과 마찬가지로 원하는 위치를 마음대로 읽을 수 있다.
    - 근데 데이터 기록을 위해서는 먼저 0을 채워넣어야 한다. 0을 1로 바꿀수는 있지만 전체를 지우지 않고 원하는 비트만 0으로 되돌릴수는 없다.
    - 읽을 때 -> 임의 접근, 쓸 때 -> 블록 접근

## 오류 감지와 정정

- 복사본 2개 더 만들기
    - 데이터를 비교해서 둘 이상 일치하는 쪽이 맞는다고 판단
    - 이거는 혹독한 환경일 경우
- 패리티 비트
    - 1로 설정된 비트 숫자를 세는것
    - 이거는 그냥 1비트만 잘못된 경우만 감지 가능하다.
- 해밍 코드
    - 더 많은 오류 탐지 가능 + 오류 부분이 적으면 바로 수정 가능
