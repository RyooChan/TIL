- 1장
    - 언어
        - 의사소통을 위해 쓰고, 문맥에 따른 의미
    - 문자 언어
        - 기호의 나열
    - 비트
        - 'binary' + 'digit' -> 요거 두개를 합친 말이라고 함
        - 2진법 사용
    - 논리 연산
        - 논리적으로 예/아니오
    - 불리언대수
        - 비트에 대해 사용 가능한 연산 규칙 집합
        - 결합법칙, 교환법칙, 분배법칙을 적용 가능
        - NOT : 논리적 반대
        - AND : 전부 참이어야 참
        - OR : 하나라도 참이면 참
        - XOR : 서로 달라야 참
    - 드모르간의 법칙
        - (A and B) == NOT(NOT A or NOT B)
    - 정수를 비트로 표현
        - 2진수 쓰자
        - 그럼 음수는?
            - 부호화 크기 표현법
                - 한 비트를 부호에 사용, 나머지 비트를 0부터의 크기를 표현 -> 잘 안쓰임
                    - 비트 구성에의 비용에서 0을 표현하는 방법이 2가지라 비용 낭비
                    - 덧셈 계산 불가능
            - 1의 보수
                - 양수의 모든 비트를 뒤집기
                    - 7 -> 0111(2)
                    - 6 -> 0110(2)
                    - 6 -> 1001(2)
                    - 7 -> 1000(2)
                - 부호와 크기 표현법과 비슷하게 비트를 부호 비트와 나머지로 나눔
                - 문제는 동일
                - 그리고 MSB(가장왼쪽비트)에서 올림이 있으면 LSB(가장오른쪽비트)로 올림 전달하는 순환 올림이 필요 -> 복잡하고 순환올림 처리 따로 필요
            - 2의 보수
                - 요즘은 이걸 쓴다.
                - 숫자를 뒤집어서 1 더하는걸 음수로 표현하기
            - 참고로 이런 방식들은 문맥에 따라 어떤걸 썼냐를 알아두는게 좋을것이다.
        - 그럼 실수는
            - 고정소수점 표현법
                - 임의로 2진 소수점 위치를 정하는거
                    - 예를들어 4비트면 (왼쪽2비트는 정수) (오른쪽2비트는 소수점) 이런식으로
                    - 이거 좋기는 한데 범용컴퓨터(좀 일반적으로 다양한 역할로 쓰는거)에서는 넓은 범위의 수를 다뤄야 하는데 이럴려면 큰 숫자를 쓸거고 -> 그러면 지금 방식은 너무 필요 비트가 많아질것이다.
            - 부동소수점 표현법
                - 과학적 표기법을 2진수에 적용
                    - 가수 * (2의지수배) 로 하는거
                        - 그니까 10진수에서 13 * 10^2 이런것처럼
                        - 2진수에서는 (1 * 1/2) * 2^2 이런식으로
                            - 가수를 만들고 거기다가 지수를 곱하는거
                    - 2의 지수배를 곱하니까 큰 수를 표현하기 좋다.
                    - 소수점의 이동이 가능하다.
                    - 다만, 딱봐도 엄청 비효율적이다.
                        - 0.0 * 2^0 ~ 0.0 * 2^3 => 싹다 0
                        - 비트패턴이 가능한 모든 수를 표현하지 못함
                            - 이게 보면 지수가 커질수록 패턴사이 값차이가 커짐
                            - => 근데 이게 왜 모든 수를 표현하지 못하는걸까?
                                - 지수가 커지면 얘가 차이가 커져서 중간에 값을 표현하기 골때림 -> 2 4 8 16 32 64 ...
                    - 자바에서 그래서 double같은거 쓰면 이상한 결과가 나오는 떄가 많다.
                    - 
                    
                    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/49a784e3-39b0-4ed1-ab9a-37c0c7b18bbd/f01379d8-e602-4fe3-8ce8-9876fcf1a94f/Untitled.png)
                    
                    - 
                    
                    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/49a784e3-39b0-4ed1-ab9a-37c0c7b18bbd/2da84bf3-a0c4-4e5d-9230-ac62ec34e6d5/Untitled.png)
                    
                - 그래서 보니까 블록체인같은거 구현할떄는 float 연산을 지원하지 않는다함
    - 2진코드화한 10진수 시스템(BCD : binary-coded decimal)
        - 2진수로 수를 표현하는 방법중 하나
        - 4비트를 사용해 10진 숫자를 표현한다.
        - 12 -> 0001 0010 (2)
            - 0001 -> 10의자리 1
            - 0010 -> 1의자리 2
        - 척봐도 뭔가 많이 써야함 -> 잘 안쓰임
    - 2진수를 다루는 쉬운 방법
        - 2진수로 되어있으면 보기 힘듦
        - 8진 표현법
            - 말 그대로 3비트씩 묶어서 보여주기
        - 16진
            - 4비트씩
            - 이게 많이 쓰이는 이유는 요즘 컴퓨터 내부가 8비트의 배수를 사용해서 만들어져서임
    - 비트 그룹 이름
        - 니블 : 4bit
        - 바이트 : 8bit
        - 하프 워드 : 16bit
        - 워드 : 32bit
        - 더블 워드 : 64bit
    - 텍스트 표현
        - 아스키 코드
            - 우리가 알고있는 그거임, 사실 표준이었음
        - 유니코드
            - 아스키는 기본적으로 영어 기반이라 다른 언어들을 지원하기 위해 도입
            - 16비트로 시작해서 지금은 21비트까지 확장됐다.
            - 유니코드 변환 형식 8비트
                - 컴퓨터는 아직 8비트를 사용해 문자를 표현함
                - 그래서 유니코드를 문자 코드에 따라 다른 인코딩을 사용해 해결함
                    - 인코딩이란 : 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴
                - UTF-8
                    - 아스키코드는 그냥 8비트라 고대로 사용
                    - 문자를 8비트 덩어리(옥텟)의 시퀀스로 인코딩
                    - 0 -> 1바이트 / 110 -> 2바이트 / 1110 -> 3바이트 / 11110 -> 4바이트
                    - 10 -> 이거는 위에서 2, 3, 4바이트 등을 쓴다고 알려주면 그 다음부터 요렇게 나타남
                    - 문자를 사용한 수 표현
                        - QP인코딩(출력 가능하게 변경한 인코딩 == Quoted Printable Encoding)
                            - = 다음에 바이트의 각 니블을 표현하는 16진 숫자 2개를 추가해 8비트값을 표현
                                - 아스키 코드가 아닌것들은 =EA=80 이런식으로 =뒤에 있는 니블로 표현하도록 작성하는것.
                                - 딱보면 1바이트 표현을 위해 3바이트를 사용해서 매우 비효율적
                        - Base64
                            - 3바이트 데이터를 4문자로 표현
                                - 3byte -> 24bit 이거를 6bit짜리 4개로 나눠서 표현
                                - 원본데이터가 1바이트남으면 마지막에 =, 2바이트 남으면 ==
                        - URL인코딩
                            - Percent-Encoding이라고도 함
                            - % 뒤에 16진 표현을 덧붙인다
                            - 예를들어 / 가 따로 의미없이 쓰이기를 원하면 %2F 이렇게
    - 색 표현
        - 24비트 RGB -> 근데 24비트는 잘 안쓰고 컴퓨터에서 32비트 쓰니까 32비트를 사용
        - 투명도
            - 위에서 RGB각각 1바이트니까 남는 1바이트를 투명도로 사용
            - 소숫점단위가 아니라 255(8비트) 에서 분수로 표현 (0.5면 127해서 255의 절반정도)
            - 그리고 이 투명도(위에서는 0.5)를 색깔에 곱해서 저장하는것
        - 색 인코딩
            - 16진 트리플렛 -> #ffffff 이런거
- 2장
    
    하드웨어 : 비트에 대해 동작하는 장치를 포함해 모든 물리적인 장치
    그 중에서 `조합 논리`(불리언 대수) 를 구현하는 하드웨어에 대해 살펴볼 것이다.
    
    - 디지털 컴퓨터의 사례
        - 톱니바퀴 이용
            - 두 바퀴의 상대적 회전 속도를 통한 계산
        - 계산자
            - `log(x*y) = log(x) + log(y)` 를 이용하여 계산하는것
            - 앞의 x만큼 띄어서 y해당 계산자를 붙이면 곱셈값을 구할 수 있다.
            - 추가로 이거 밑이 10인 상용로그라 10의 거듭제곱도 쉽게 구할수있음(그거는 그냥 숫자처리하면 되니까)
        - 차분기관같은것도 있었다고 함
    - 아날로그 디지털 차이
        - 디지털 : 이산적 -> 하나하나 다른 존재로 구분된다. 정수만 표현 가능
        - 아날로그 : 연속적 -> 실수를 표현 가능
        - 즉 계산자같은 애들은 아날로그 컴퓨터임
            - 이거는 문제가 실수의 범위가 커질수록 찾기가 쉽지 않다는것
            - 하드웨어에서는 크기가 중요하다.
                - 컴퓨터 클록 속도가 40GHz라고 하면 1초에 40억개의 계산을 할 수있다는 것이다.
                - 이게 결국 전자가 어떤 속도로 이동해야하는거 -> 따라서 하드웨어 크기가 작으면 효율적인것이다.
                - 근데 물체가 너무 작으면 속도나 효율은 좋아지지만 간섭하기가 아주 쉬워진다.
                    - 그래서 디지털을 만드는것이 필요한데, 생각해보면 디지털이라는게 어쨌든 아날로그 세상에 존재하는것이다. -> 그래서 어떻게든 디지털로 만들어야 할 것
    - 아날로그에서 디지털 만들기
        - 전이 함수
            - 
                
                https://github.com/RyooChan/TIL/assets/53744363/038e165b-ac09-4967-a273-43ffee5a942f
                
            - 중요한건 함수에 있어 상단부/하단부가 아닌 직선부에 닿도록 해야하는것(그래야 너무 밝거나 어둡거나 하지 않으니)
            - 만약 증폭 전이 함수의 기울기가 크면(직선부가 가파르면) 출력이 이상해짐
                1. 입력의 범위가 직선부뿐 아니라 상단/하단부에 해당하면 왜곡이 생김
                2. 출력이 확 커짐
                - 이런 입력이 조금만 번해도 곡선의 가파른 부분 때문에 출력이 커지는 판정 기준을 문턱값이라고 한다.
                    - 여기서 보면 이런 문턱값의 왜곡 발생은 결국 하단부 -> 상단부로의 변경을 뜻하는 것인데(말하자면 직선부를 지나쳤다 - 계단이 변경됨) 이를 통해 왜곡으로 디지털 값을 만들수 있다.
                        - 디지털은 결국 직선부를 최대한 작게 만드는 것
    - 10진 숫자 대신 비트를 사용하는 이유
        - 당연한거임 -> 10진수 만드는것보다 그냥 문턱값에서 하나 올리면서 그거를 10개 쓰는게 나음
        - 하단부 : 차단 / 상단부 : 포화
        - 전이함수를 아주 가파르게 하면 간단!
    - 비트를 처리하기 위한 하드웨어
        - 릴레이, 진공관 -> 속도가 느림
        - 트랜지스터
            - transfer resistor(전송 저항)의 줄임말
            - 여러 유형이 있는데 중요한 두 가지 유형
                - BJT(쌍극 접합 트랜지스터)
                    - 전기가 한 방향으로만 흐른다.
                - FET(전계 효과 트랜지스터)
                    - 정전기 효과를 사용해 스위치 움직임
                    - MOSFET(금속산화물 반도체 전계 효과 트랜지스터) 라는게 있는데 이거는 FET의 일종이고 전력 소모가 적어서 현대 컴퓨터 칩에서 가장 널리 쓰이는중이다.
        - 집적 회로
            - 트랜지스터를 쓰면 간단한 회로를 만들 때에도 부품이 너무 많이 필요
            - 복잡한 시스템을 간단히 만들 수 있다.
            - 칩이라고도 불림
    - 논리 게이트
        - AND / OR / XOR / 인버터(NOT)같은 애들을 미리 만들어놓은 게이트
        - NAND / NOR
            - 얘들은 논리 게이트에서 가장 단순한애들
            - 그래서 싸고 반응속도도 빠르고 전력소모도 적음
                - 그래서 기본적으로 이것들이 쓰인다.
        - 참고로 입력이 3개인 것도 있음
        - **이력 현상**을 활용한 잡음 내서 향상
            - 위의 게이트를 써서 논리 신호가 0->1 1->0 순식간에 샥샥 가는게 아님
            - 대부분 천천히 바뀌는 경우가 많고 잡음이 있으므로 문턱값을 여러번 오락가락하는 글리치(작은 오류) 바랭
            - 이런거를 이력 현상을 위해 방지 가능하다.
                - 이력 현상이란 판정 기준이 이력(과거에 벌어진 일)에 따라 달라진다는 뜻
                - 0 -> 1 : 오른쪽 곡선 사용(/ 요런 형태)
                - 1 -> 0 : 왼쪽 곡선 사용(\ 요런 형태)
                - 여기서 보면 올라가는신호랑 내려가는신호는 각각 다른 문턱값이 생긴다.
                    - 즉, 입력신호가 두 문턱값중 하나를 넘어간 경우, 반대쪽 문턱값을 지나가며 출력이 반전되려면 값이 많이 변해야 한다는 것이다. -> 잡음 내성이 커진다(흔들려서 실수로 내려가는 경우에 곡선이 반대면 크기에 따른 판별 가능)
            - 요거를 활용하는 게이트가 슈미트 트리거
                - 참고로 이거는 비싸고 복잡해서 필요한 경우에만 사용한다.
        - 차동 신호
            - 잡음이 너무 많으면 위의 이력으로 충분하지 않을 수 있다.
            - 그래서 아예 2개를 만들어서 서로의 상대적 위치로 판단할 수 있다.
                - 그런 경우는 잡음으로 위치 높낮이가 커져도 상대적 위치가 같으므로 (XO / OX) 값이 일정
            - 이게 어떻게 가능한지?
                - 드라이버를 통해 한번에 받은 신호를 하나는 그대로, 하나는 반전(O -> O,X)
                - OX인 상태로 가니까 잡음이 있건 없건 그대로 송신
                - 리시버로 그걸 다시 전환(OX + 잡음이여도 어차피 위치는 아니까)
        - 전파 지연
            - 입력의 변화가 출력에 영향을 미칠 때까지 걸리는 시간
            - 정확한 값은 아니고 측정값이다. 그리고 이거를 잘 계산해서 설계해야한다.(출력이 언제올지를 알아야하니까)
        - 출력 유형
            - 토템폴 출력
                - 일반적인 게이트 출력
                - 트랜지스터가 토템폴처럼 세로로 나란히 늘어서 있어서 붙음
                
                https://github.com/RyooChan/TIL/assets/53744363/a58a15d1-958c-488c-af3f-bc1b2437c109
                
                - 각각 스위치는 서로 반대로 동작(하나가 ON되면 하나는 OFF)
                - 
                    
                    https://github.com/RyooChan/TIL/assets/53744363/10f321c5-5eb2-41dc-80bb-5591f33d07a8
                    
                - 요렇게 생각할 때 ON이라 하면(위쪽에만 연결, 아래애는 끊김)
                - 
                    
                    https://github.com/RyooChan/TIL/assets/53744363/7739e7f0-4282-4c1e-8820-6146fe71e7be
                    
                - 이런 식으로 H가 되고
                - 만약 반대로 OFF라 하면(위쪽이 끊기고 아래가 연결)
                - 
                    
                    https://github.com/RyooChan/TIL/assets/53744363/503401f2-9a96-4c38-a870-985c5139c6fb
                    
                - 요렇게 L가 되어 출력이 없는것
                - 액티브 풀업이라 서로 연결하면 안된다.
                    - 즉 둘다 ON이라면?
                    - 
                        
                        https://github.com/RyooChan/TIL/assets/53744363/cc6d934c-893b-4769-a896-eadb8495f268
                        
                    - 그냥 흘러버려서 전류가 확 커져서 큰일남(불탐)
            - 오픈 컬렉터 출력
                - 오픈컬렉터 / 오픈트레인
                - 
                    
                    https://github.com/RyooChan/TIL/assets/53744363/2e8ca171-1698-40d0-a3ea-a972c41e67e2
                    
                - 원하는게 0이면 되는데, 1이면 걍 떠있다.
                - 1이면 전류가 그냥 흘러가는 상태로 둬서 AND 유지된다.
                - 0이면 AND쪽이 아니라 연결된쪽으로 흘러서 AND가 되지 못한다.
                    - 하나라도 끊어져 있으면 싹다 안되는거지
                - 이거는 출력이 여러개 있는 액티브 풀업이 아니기 때문에 출력을 연결 가능하다.
                    - 그냥 흐르는지 / 흐르지 않는지이니까
                    - 
            - 트라이스테이트 출력
                - 오픈컬렉터는 출력 연결은 되는데 액티브 풀업보다 속도가 느리다.
                - 토템폴에서 트라이스테이트 출력을 한쪽에다가 더해준다.
                - 
                    
                    https://github.com/RyooChan/TIL/assets/53744363/1a693529-a1f7-46ad-9413-344202a23664
                    
                - 요런 느낌으로 하나 추가해주면
                - 
                    
                    https://github.com/RyooChan/TIL/assets/53744363/7fc249e8-b170-4e43-92ce-0081ba88404b
                    
                - 
                    
                    https://github.com/RyooChan/TIL/assets/53744363/3e3ef1d9-d855-4c5c-b744-698671fd0b12
                    
                - 요런 식으로 둘다 스위치를 동일하게 ON/ON, OFF/OFF 이렇게 해도 다르게 동작하도록 해주는것
- 3장
    
    순차 논리란, 순서에서 비롯된 말이다.
    즉 시간적으로 어떤 값 뒤에 오는 다른 값이라는 건데
    그동안 배웠던 조합 논리는 입력의 현재 상태만을 다뤘다면 순차논리는 현재와 과거를 함께 고려한다.
    
    ## 시간 표현과 상태 기억
    
    - 주기함수를 사용해 시간 측정
        - 예를 들어 지구의 자전이 주기함수임.
    - 발진자
        - 
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/49a784e3-39b0-4ed1-ab9a-37c0c7b18bbd/e0b09460-b94e-47ee-938c-97d3b5d142bd/Untitled.png)
        
        - 요런 식으로 주기에 맞춰 피드백을 돌려주는거
        - 이게 정확하게 하려면 크리스탈을 활용하면 된다.
    - 클록
        - 발진자를 통한 시간 측정
        - 참고로 이걸 통해 컴퓨터가 시간을 측정하기 때문에 오버클로킹하면 클록을 빠르게 공급 가능
    - 래치
        - 
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/49a784e3-39b0-4ed1-ab9a-37c0c7b18bbd/741a0532-15f5-45dc-894c-feaa664841d5/Untitled.png)
        
        - OR게이트 출력을 입력에 묶는 피드백을 통해 정보 기억 가능
            - 요렇게 하면 입력이 들어온 다음부터는 무조건 1이 될것이다.
            - 이를 해결하기 위해 회로 재설정 과정이 요렇게
            - 
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/49a784e3-39b0-4ed1-ab9a-37c0c7b18bbd/98d82646-0f09-4bfb-bf4a-bbbc5921897c/Untitled.png)
            
            - 여기서 reset위에 줄그어진거는 반전이라는 것이다.
                - 동작을 간단하게 말하자면 set1이 1이면 계속 1이다가 reset이 1이 들어오면 -> 반전연산에 의해 0으로 바뀌는(그때 set은 0이어야 한다)것.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/49a784e3-39b0-4ed1-ab9a-37c0c7b18bbd/f95feb7d-2eb5-4e9d-b4e9-9d63cf90c7e6/Untitled.png)
    
    - 요렇게 하면 대칭이라 set reset신호 지연 시간이 거의 비슷하다.
    - 게이트가 있는 래치
        - 게이트가 있는 S-R 래치
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/49a784e3-39b0-4ed1-ab9a-37c0c7b18bbd/b4c3be12-a8ec-485b-82d9-e080b8679adf/Untitled.png)
            
            - 이거 보면 gate의 반전이 거짓(1)이면 set, reset이 무엇이든 관계 없이 1로 출력이 유지된다.
        - 게이트가 있는 D래치
            - 
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/49a784e3-39b0-4ed1-ab9a-37c0c7b18bbd/bdda3bfd-60f7-456e-a8d2-3e0cff498ae0/Untitled.png)
            
            - 
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/49a784e3-39b0-4ed1-ab9a-37c0c7b18bbd/059eaf7a-1b32-4eb7-86b5-9a38fb08e506/Untitled.png)
            
            - 여기서는 gate의 반전이 거짓이면 D가 변해도 Q출력에 아무 변화가 없다.
            - 근데 이거 문제는 gate의 반전이 참(0)인 상태에서는 D의 변화가 그대로 출력에 나타난다는 점
                - 게이트가 열려 있는 동안에는 스스로의 상태를 바꾸지 않아야 하는데, -> 즉 게이트 여는 시간을 최소화해서 순간적으로 D의 상태에 맞춰 출력 상태를 변경할 수 있다면 좋음
    - 플립플롭
        - 위에서 봤던 것처럼 데이터 변경으로 인해 잘못된 결과가 생길 수 있는 가능성을 최소화하는게 좋다.
        - 가장 많이 사용되는건 논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는것.
            - 이런걸 엣지(edge)라고 부른다.
                - 엣지를 시간에 대한 판정 기준이라고 생각할 수 있다.
        - 에지에 의해 데이터 변화가 촉발되는 래치를 플립플롭이라고 한다.
            - 뭔가 종류가 있는것같기는 한데, 그냥 얘의 역할은 어쨌든 이것이다.
            - 즉, 변화가 있을 때까지 데이터를 유지하다가, 변화가 생기면 이를 바로 캐치할 수 있는것
    
    ## 메모리 조직과 주소 지정
    
    - 비트 기억에 플립플롭 유용하고, 레지스터는 여러 비트 저장
        - 그러면 많은 정보는?
    - 주소를 부여한 레지스터를 쌓아서 하기
        - 여러개를 쌓아서 번호를 부여한다.
            - 주소 버스랑 데이터 버스를 통해 이를 찾아가기
                - 참고로 행과 열 주소를 멀티플렉싱하면 주소 라인의 수를 반으로 줄일 수 있다.
                    - 여기서는 주소 저장을 위한 레지스터가 사용된다.
    
    ## 임의 접근 메모리
    
    - 지금까지 살펴본거를 RAM(Random Access Memory : 임의 접근 메모리)이라고 한다.
    - 정적램
        - 비싸지만 빠름.
        - 각 비트에 트랜지스터가 6개 들어간다.
        - 트랜지스터는 공간을 차지하기 때문에 SRAM은 수십억 ~ 수조 비트를 저장하기 좋은 선택은 아님
    - 동적램
        - 커패시터라는 작은 버킷에 전자를 담고, 트랜지스터 하나만 사용해 뚜껑 닫기
            - 근데 이 버킷은 자주 새기 때문에 가끔 메모리 갱신이 필요하다.
        - 이거는 집적도가 높아서 큰 메모리 칩에 사용된다.
    - 참고로 램은 모두 휘발성이다.
    
    ## 읽기 전용 메모리
    
    - ROM(Read Only Memory)
    - 참고로 읽기전용은 아니고, 한번밖에 못쓰는 메모리임.
    - 이거는 비휘발성
    
    ## 블록 장치
    
    - 디스크
        - 이거는 한번 지나간 데이터를 다시 읽으려면 다시 한바퀴 돌아야한다.
    
    ## 플래시 메모리와 SSD
    
    - 플래시 메모리는 최근 나타난 EEPROM유형 매체
        - DRAM과 마찬가지로 버킷에 전자를 담는데, 버킷이 크고 더 잘 만들어져 있어 전자가 새지 않는다.
        - RAM과 마찬가지로 원하는 위치를 마음대로 읽을 수 있다.
        - 근데 데이터 기록을 위해서는 먼저 0을 채워넣어야 한다. 0을 1로 바꿀수는 있지만 전체를 지우지 않고 원하는 비트만 0으로 되돌릴수는 없다.
        - 읽을 때 -> 임의 접근, 쓸 때 -> 블록 접근
    
    ## 오류 감지와 정정
    
    - 복사본 2개 더 만들기
        - 데이터를 비교해서 둘 이상 일치하는 쪽이 맞는다고 판단
        - 이거는 혹독한 환경일 경우
    - 패리티 비트
        - 1로 설정된 비트 숫자를 세는것
        - 이거는 그냥 1비트만 잘못된 경우만 감지 가능하다.
    - 해밍 코드
        - 더 많은 오류 탐지 가능 + 오류 부분이 적으면 바로 수정 가능
