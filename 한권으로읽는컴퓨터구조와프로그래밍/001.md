- 언어
    - 의사소통을 위해 쓰고, 문맥에 따른 의미
- 문자 언어
    - 기호의 나열
- 비트
    - 'binary' + 'digit' -> 요거 두개를 합친 말이라고 함
    - 2진법 사용
- 논리 연산
    - 논리적으로 예/아니오
- 불리언대수
    - 비트에 대해 사용 가능한 연산 규칙 집합
    - 결합법칙, 교환법칙, 분배법칙을 적용 가능
    - NOT : 논리적 반대
    - AND : 전부 참이어야 참
    - OR : 하나라도 참이면 참
    - XOR : 서로 달라야 참
- 드모르간의 법칙
    - (A and B) == NOT(NOT A or NOT B)
- 정수를 비트로 표현
    - 2진수 쓰자
    - 그럼 음수는?
        - 부호화 크기 표현법
            - 한 비트를 부호에 사용, 나머지 비트를 0부터의 크기를 표현 -> 잘 안쓰임
                - 비트 구성에의 비용에서 0을 표현하는 방법이 2가지라 비용 낭비
                - 덧셈 계산 불가능
        - 1의 보수
            - 양수의 모든 비트를 뒤집기
                - 7 -> 0111(2)
                - 6 -> 0110(2)
                - -6 -> 1001(2)
                - -7 -> 1000(2)
            - 부호와 크기 표현법과 비슷하게 비트를 부호 비트와 나머지로 나눔
            - 문제는 동일
            - 그리고 MSB(가장왼쪽비트)에서 올림이 있으면 LSB(가장오른쪽비트)로 올림 전달하는 순환 올림이 필요 -> 복잡하고 순환올림 처리 따로 필요
        - 2의 보수
            - 요즘은 이걸 쓴다.
            - 숫자를 뒤집어서 1 더하는걸 음수로 표현하기
        - 참고로 이런 방식들은 문맥에 따라 어떤걸 썼냐를 알아두는게 좋을것이다.
    - 그럼 실수는
        - 고정소수점 표현법
            - 임의로 2진 소수점 위치를 정하는거
                - 예를들어 4비트면 (왼쪽2비트는 정수) (오른쪽2비트는 소수점) 이런식으로
                - 이거 좋기는 한데 범용컴퓨터(좀 일반적으로 다양한 역할로 쓰는거)에서는 넓은 범위의 수를 다뤄야 하는데 이럴려면 큰 숫자를 쓸거고 -> 그러면 지금 방식은 너무 필요 비트가 많아질것이다.
        - 부동소수점 표현법
            - 과학적 표기법을 2진수에 적용
                - 가수 * (2의지수배) 로 하는거
                    - 그니까 10진수에서 13 * 10^2 이런것처럼
                    - 2진수에서는 (1 * 1/2) * 2^2 이런식으로
                        - 가수를 만들고 거기다가 지수를 곱하는거
                - 2의 지수배를 곱하니까 큰 수를 표현하기 좋다.
                - 소수점의 이동이 가능하다.
                - 다만, 딱봐도 엄청 비효율적이다.
                    - 0.0 * 2^0 ~ 0.0 * 2^3 => 싹다 0
                    - 비트패턴이 가능한 모든 수를 표현하지 못함
                        - 이게 보면 지수가 커질수록 패턴사이 값차이가 커짐
                        - => 근데 이게 왜 모든 수를 표현하지 못하는걸까?
                            - 지수가 커지면 얘가 차이가 커져서 중간에 값을 표현하기 골때림 -> 2 4 8 16 32 64 ...
                - 자바에서 그래서 double같은거 쓰면 이상한 결과가 나오는 떄가 많다.
                - ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/49a784e3-39b0-4ed1-ab9a-37c0c7b18bbd/f01379d8-e602-4fe3-8ce8-9876fcf1a94f/Untitled.png)
                - ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/49a784e3-39b0-4ed1-ab9a-37c0c7b18bbd/2da84bf3-a0c4-4e5d-9230-ac62ec34e6d5/Untitled.png)
            - 그래서 보니까 블록체인같은거 구현할떄는 float 연산을 지원하지 않는다함
- 2진코드화한 10진수 시스템(BCD : binary-coded decimal)
    - 2진수로 수를 표현하는 방법중 하나
    - 4비트를 사용해 10진 숫자를 표현한다.
    - 12 -> 0001 0010 (2)
        - 0001 -> 10의자리 1
        - 0010 -> 1의자리 2
    - 척봐도 뭔가 많이 써야함 -> 잘 안쓰임
- 2진수를 다루는 쉬운 방법
    - 2진수로 되어있으면 보기 힘듦
    - 8진 표현법
        - 말 그대로 3비트씩 묶어서 보여주기
    - 16진
        - 4비트씩
        - 이게 많이 쓰이는 이유는 요즘 컴퓨터 내부가 8비트의 배수를 사용해서 만들어져서임
- 비트 그룹 이름
    - 니블 : 4bit
    - 바이트 : 8bit
    - 하프 워드 : 16bit
    - 워드 : 32bit
    - 더블 워드 : 64bit
- 텍스트 표현
    - 아스키 코드
        - 우리가 알고있는 그거임, 사실 표준이었음
    - 유니코드
        - 아스키는 기본적으로 영어 기반이라 다른 언어들을 지원하기 위해 도입
        - 16비트로 시작해서 지금은 21비트까지 확장됐다.
        - 유니코드 변환 형식 8비트
            - 컴퓨터는 아직 8비트를 사용해 문자를 표현함
            - 그래서 유니코드를 문자 코드에 따라 다른 인코딩을 사용해 해결함
                - 인코딩이란 : 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴
            - UTF-8
                - 아스키코드는 그냥 8비트라 고대로 사용
                - 문자를 8비트 덩어리(옥텟)의 시퀀스로 인코딩
                - 0 -> 1바이트 / 110 -> 2바이트 / 1110 -> 3바이트 / 11110 -> 4바이트
                - 10 -> 이거는 위에서 2, 3, 4바이트 등을 쓴다고 알려주면 그 다음부터 요렇게 나타남
                - 문자를 사용한 수 표현
                    - QP인코딩(출력 가능하게 변경한 인코딩 == Quoted Printable Encoding)
                        - = 다음에 바이트의 각 니블을 표현하는 16진 숫자 2개를 추가해 8비트값을 표현
                            - 아스키 코드가 아닌것들은 =EA=80 이런식으로 =뒤에 있는 니블로 표현하도록 작성하는것.
                            - 딱보면 1바이트 표현을 위해 3바이트를 사용해서 매우 비효율적
                    - Base64
                        - 3바이트 데이터를 4문자로 표현
                            - 3byte -> 24bit 이거를 6bit짜리 4개로 나눠서 표현
                            - 원본데이터가 1바이트남으면 마지막에 =, 2바이트 남으면 ==
                    - URL인코딩
                        - Percent-Encoding이라고도 함
                        - % 뒤에 16진 표현을 덧붙인다
                        - 예를들어 / 가 따로 의미없이 쓰이기를 원하면 %2F 이렇게
- 색 표현
    - 24비트 RGB -> 근데 24비트는 잘 안쓰고 컴퓨터에서 32비트 쓰니까 32비트를 사용
    - 투명도
        - 위에서 RGB각각 1바이트니까 남는 1바이트를 투명도로 사용
        - 소숫점단위가 아니라 255(8비트) 에서 분수로 표현 (0.5면 127해서 255의 절반정도)
        - 그리고 이 투명도(위에서는 0.5)를 색깔에 곱해서 저장하는것
    - 색 인코딩
        - 16진 트리플렛 -> #ffffff 이런거
