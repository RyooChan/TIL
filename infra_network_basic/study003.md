## Storage

스토리지는 일반적으로 컴퓨터에서 데이터를 비휘발성으로 저장할 수 있는 저장장치를 뜻한다.

최근 인공지능이나 IoT등 다양한 IT기술들이 등장함에 따라 데이터의 양이 많아지기 시작하며 다양한 데이터 스토리지 기술들이 조명받기 시작했다.

## RAID구성을 도와주는 Array Controller

여러 개의 저장장치를 묶어 하나의 디스크처럼 사용할 수 있도록 도와주는 기술이다.

이를 할 수 있도록 도와주는 것이 바로 Array Controller이다. == RAID Controller == RAID Card

## RAID

다양한 종류가 있는데, 이 중 중요한 것들에 관해서만 설명한다.

그리고 각 RAID레밸에 관해서는 가용성과 용량에 집중해서 살펴보는 것이 좋다.

### RAID 0

![](https://i.imgur.com/qBbmIUL.png)

스트라이핑 기술을 이용하여 데이터 세그먼트들을 여러 디스크 디바이스로 분산 기록하는 방식이다.

#### 데이터 세그먼트

서버에 파일을 올렸을 때에 우리 입장에서는 하나의 데이터로만 보이겠지만 서버 내부에서는 작은 조각으로 나누어서 보관하게 된다. 이것을 데이터 세그먼트라고 부른다.

즉, 이 방식은 데이터를 분산 저장하는 방식이라 생각하면 된다.

그런데 만약 하나의 DIsk가 Fault가 나면 어떻게 될까??

아마 전체 데이터를 잃어버리게 될 것이다.

그래서 실무에서 이 방식은 잘 안쓴다.

용량의 경우 300GB + 300GB인 경우 가용 용량은 600GB가 된다.

### RAID 1

![](https://i.imgur.com/DglpPBn.png)

기존의 RAID0의 문제를 미러링을 통해 보안한 방식이다.

RAID1은 데이터 세그먼트를 다른 디스크로 복제본을 만들어 저장한다.

그렇기 때문에 Disk가 하나 망가지더라도 다른 Disk의 세그먼트가 살아있기 때문에 데이터 유실이 발생하지 않을 것이다.

즉 가용성이 높을 것이다.


용량의 경우 300GB + 300GB = 300GB이다. 왜냐면 같은 데이터를 복사해서 가지고 있기 떄문에.

### RAID 5

![](https://i.imgur.com/pxu1Yw9.png)

패리티라는 기술을 이용하여 가용성을 제공한다.

앞에 있던 RAID 1에서는 미러링을 이용해서 완전히 동일한 크기의 공간을 필요로 했기 때문에 가용 용량이 절반밖에 되지 않았다.

여기서는 가용성을 어느 정도 보장하면서도 가용 용량을 높일 수 있다.


* 패리티
    * 디스크 장애시 데이터를 재구축하는 데에 사용할 수 있는 사전에 계산된 값.
    * 패리티틀 저장해야 하는 디스크는 단 1개만 있으면 된다.

위의 사진의 경우 1개의 디스크만 패리티를 위해 사용되기 때문에

300GB + 300GB + 300GB + 300GB = 900GB가 된다.

다만 이 패리티 비트를 사용하는 경우 내부적으로 복잡한 연산을 진행하다 보니 디스크가 망가질 확률이 높다.

그래서 실제로 하드 디스크를 많이 사용할 때에는 해당 방식을 지양하는 편이다.

### RAID 6

![](https://i.imgur.com/OUrZlxo.png)

데이터마다 2개의 패리티를 구성한다.

그래서 이건 디스크 2개를 소모하게 되지만 안정성을 생각한다면 이정도는 해줄만 하다.

디스크 2개가 망가지더라도 데이터 손실로 이루어지지는 않는다.

RAID 5정도의 성능을 갖기 위해서는 디스크 한개가 더 필요하다.

### RAID 10

![](https://i.imgur.com/724mdMN.png)

RAID0 과 RAID1 를 한꺼번에 사용하는 방식이다.

앞에 나오는 숫자가 하위 배열, 뒤에 나오는 숫자가 상위배열이다.

먼저 Disk1과 Disk2가 RAID1으로 묶여 있으니 해당 Array에서는 하나의 Disk가 고장나도 다른 쪽에서 받쳐 줄 수 있을 것이다.

다음으로 Disk3과 Disk4도 마찬가지일 것이다.

즉 이런식으로 RAID1으로 되어 있으면 하나가 고장나더라도 다른 쪽에서 받쳐줄 수 있다.

![](https://i.imgur.com/QS66eiW.png)

### 그 외 자주 사용되는 기술과 용어들 - Hot Spare, Rebuilding

때에 따라서 여러 디스크가 한번에 나가는 경우도 있다.

이 때에 조금 더 안전하게 환경을 구성하고 싶을 때에 사용하는 것이 Hot Spare 이다.

Hot Spare 은 기존에 구성된 RAID에 디스크 하나를 더 설치한다.

이를 통해 RAID로 구성된 Disk가 하나 Fault날 경우, Spare디스크가 망가진 디스크를 바로 대체하게 된다.

우리가 Disk Fault를 늦게 확인해서 망가진 Disk를 신규 Disk로 교체하는걸 늦게 할 수도 있기 때문에 Hot Spare가 큰 역할을 해준다.

다만 신규 디스크를 넣었다고 바로 RAID가 온전히 복구되지는 않는다.
이 새로운 디스크에 기존 데이터를 맞추기 위해 데이터를 부어주는 작업도 해야 할 것이다.
이러한 일련의 과정을 Rebuilding 이라고 부른다.

> 그런데 신규 입사자들이 많이 하는 실수가, 디스크 교체 완료 이후로 작업 완료로 생각하는 경우가 있는데, 확실하게 교체가 완료되었는지 확인해 보려면 IPMI등을 이용해서 리빌딩 상태가 현재 몇%인지, 완료되었는지 꼭 꼭 확인해라.


### 그 외 자주 사용되는 기술과 용어들 - JBOD

Just a Bunch of Disks(Drives)의 약어로 단순히 물리적인 디스크 여러개를 모아서 하나의 큰 하드 디스크처럼 보이도록 하는 기술이다.

RAID처럼 데이터를 분산 저장하지 않으며, 디스크 순서대로 데이터를 차곡차곡 저장한다. 확장성이 좋은 방식.

---

### 전통적인 스토리지 DAS, NAS, SAN

대표적으로 그동안 많이 사용되던 스토리지이다.

* DAS
    * 서버에 저장공간이 부족했을 때 가장 먼저 고려해볼 수 있는 스토리지
    * 전용 케이블을 이용해서 서버에 1:1 다이렉트로 연결되는 방식으로, 접근 속도가 빠르다는 장점이 있다.
    * 다만 스토리지의 Scale out 에서 문제가 발생할 수 있고, 여러 곳에서 연결하는 것이 힘들다는 단점이 있다.
* NAS
    * 서버와 스토리지가 LAN네트워크를 통해 연결된 방식이다.
    * DAS보다 활정성에서 유리하고, 여러 서버들이 공통된 스토리지를 바라보아야 할 때 적합하다.
* SAN
    * Fibre channel 기반 스위치를 통해 서버와 스토리지를 고속으로 연결할 수 있도록 해주는 타입이다.
    * 여러 스토리지를 하나로 묶어서 관리하기 때문에 대규모 확장 등 여러 곳에서 장점을 갖는다.
    * DAS와 NAS의 단점을 모두 보안한 방식이지만, 비싸다는 단점이 있다.


### 데이터를 저장하는 다양한 방식

현업에서 일할 때에 가장 많이 접하는 파일 , 블록 , 오브젝트  스토리지에 대해 알아본다.


#### 데이터를 저장하는 다양한 방식 - 파일 스토리지

![](https://i.imgur.com/jsdG3Ps.png)


파일 스토리지는 중첩된 계층 구조를 갖는 스토리지 포맷이다.

앞에서 살펴본 DAS , NAS 또한 이 방식으로 저장한다.

파일 경로를 쓰는 로컬PC 등등도 이 파일 스토리지에 해당한다.

이해하기 쉽고 편리한 인터페이스를 제공한다는 장점이 있다.

다만 파일의 경로를 찾는 이름이 길어진다는 단점이 있다.

#### 데이터를 저장하는 다양한 방식 - 블록 스토리지

![](https://i.imgur.com/pmq4aWY.png)

하나의 데이터를 고유의 식별자를 가진 블록 형식으로 쪼개서 저장한다.

그리고 데이터를 다시 불러올 때에는 이 블록 형식으로 쪼개진 데이터를 다시 하나로 뭉쳐서 전달하게 된다.

파일 스토리지와 달리 데이터가 단일 경로에 종속되지 않는다. → 그 덕분에 데이터에 더 효율적으로 접근할 수 있다.

일반적으로 SAN에서 사용하는 저장 방식이다.

다만 비용이 비싸고, 메타데이터의 관리 기능에서 아쉬운 면이 존재한다.

> 메타데이터는 뭘까??

> `#해시태그` 처럼 해당 데이터를 설명해주는 또 다른 데이터이다.

> 이 메타 데이터들은 자신을 표현할 수 있는, 혹은 부가설명을 해줄 수 있는 데이터로 우리는 이를 통해 데이터를 쉽게 검색하고, 데이터를 관리하고, 데이터를 또 다른 데이터와 연계할 수 있다.

But 저장해야 하는 데이터의 양이 점점 늘어나고 있기 때문에 기존의 스토리지 방식으로는 이 데이터를 저장하기 쉽지 않다.

기존 RAID구조로는 Petabyte규모 이상의 데이터 저장을 하기에 적합하지 않다.

그럼 데이터를 어떻게 저장할 것이고, 어떻게 보호할 것일까??

#### 데이터를 저장하는 다양한 방식 - 오브젝트 스토리지

클라우드 시대가 오면서 가장 많이 언급되는 것이 바로 오브젝트 스토리지이다.

오브젝트 스토리지는 비정형 데이터를 저장 공간에 얽매이지 않고 무제한으로 저장할 수 있다는 특징이 있다.

이 오브젝트 스토리지의 특징은 다음과 같다.

* 데이터를 객체(Object) 단위로 관리하고 조작한다.
* 객체는 실제 대상 데이터와 그 데이터의 메타데이터의 조합을 의미한다.
* 메타데이터는 데이터를 사용하는데에 있어 가장 중요한 역할을 한다.
* 오브젝트는 스토리지 풀에 flat한 형태로 저장되기 때문에 다른 계층적 스토리지에 비해서 빠르게 데이터를 검색할 수 있다.
* 스토리지 전체 용량에 제한이 없다.
* 클라우드 내에서는 일반적으로 데이터가 여러 물리적 시설에 걸쳐 데이터의 replica가 저장되므로 높은 가용성을 보장한다.
* 오브젝트 스토리지는 위의 장점 덕분에 백업 스토리지, 데이터 분석, 데이터 아카이빙 등 다양한 용도로 사용된다.


#### Sortware Defined Storage(SDS)

SDS는, Hardware에서 스토리지 소프트웨어의 종속성을 없앤 스토리지 아키텍쳐이다.

앞에서 보았던 DAS , NAS, SAN 같은 경우, 스토리지 벤더에서 하드웨어와 소프트웨어를 묶어 판매하기 때문에 원하는 하드웨어 위에 또다른 스토리지 소프트웨어를 얹어서 사용하는것이 불가능했다.

하지만 SDS가 도입되면서 표준 x86 서버라면 어디서든 동작시킬 수 있게 되었고, 또 이렇게 x86 서버 여러개를 묶어 스토리지를 만들 수 있기 때문에 무중단 서비스를 유지하면서도 scale-out 을 쉽게 할 수 있게 되었다.


#### Hyper-Converged Infrastructure(HCI)

HCI는 기존 사용하던 3Tier Architecture를 하나의 인프라 스택으로 통합시켜서 운영할 수 있게 도와주는 기술이다.

![](https://i.imgur.com/RJHYPuu.png)



##### 기존 3Tier Architecture의 문제점

![](https://i.imgur.com/P6X8jJB.png)

기존 방식에서는 이런 식으로 구성되어 있는데, 여기서의 문제는 워크로드가 늘어나면서 서버는 점점 늘어나는데 아래의 Storage Controller 는 서버와 함께 늘어나지 않는다는 것이다.

그렇기 때문에 Storage 구간에서 병목이 발생하게 된다.


#### HCI환경에서 병목 문제 해결

![](https://i.imgur.com/tVmKcAx.png)


HCI에서는 SDS기술을 활용하여 각 호스트 서버에 내장된 개별드라이브들을 논리적으로 묶어서 하나의 Storage Pool을 구성한다.

마치 기존에 사용하던 SAN과 같은 외장 스토리지와 비슷하게 만드는 것이다.

Storage뿐만 아니라, 전체적인 Infra의 scale-out이 간편해지고, Storage의 병목현상을 방지할 수 있게 된다.

De-Duplication기능을 통해 중복제거도 가능해진다. → 전체 Infra Data의 백업에서도 큰 효율을 볼 수 있다.

> 그래서 데이터 중복제거가 뭔데??

#### De-Duplication(데이터 중복제거)

데이터 중복제거, 디둡이라고 부르는 기술은 대용량 데이터에서 중복되는 데이터를 분석해서, 수정된 부분만 저장하는 기술이다.

백업을 통해 데이터를 보관하는 것은 중요한 일이지만, 이 작업이 인프라에 있어 시간적/비용적 부담을 주는 것은 별로다.

그래서 일반적으로 대규모 데이터를 보관하는 Storage에 소프트웨어적으로 중복 제거 기술을 이용해서 필요한 데이터만 빠르게 저장하고, 적은 비용으로 운영할 수 있게 도와주는 기술이다.

### Hot Data & Cold Data

* Hot Data
    * 자주 사용하는 데이터
* Cold Data
    * 자주 사용하지 않는 장기 보관 데이터




