# Effective Go

## Formatting(포맷)

Go에서 포매팅을 알아서 해줘서 코드컨벤션이 굉장히 편하게 이루어진다.

추가적으로 주의해야 하는경우는

* 들여쓰기
    * tabs을 기본적으로 사용하기
    * space는 필요할 때에만 사용하자
* 한 줄 길이
    * 길이는 제한이 없다.
    * 너무 길면 별도의 탭을 가지고 들여쓰기로 감싸자.
* 괄호
    * 제어구조에는 괄호가 없다.

## Commentary(주석)

* \/** **/
    * C언어의 블록주석
    * 주로 패키지에 사용
    * 혹은 표현식 내부
    * 혹은 많은 코드의 주석처리
* \//
    * C++의 한줄주석
    * 짧은 주석을 할 때 사용한다.

### 주석 용도

Go에서 최상위 선언문 이전에 줄바꿈 없이 주석이 나타나면 이게 선언문랑 같이 추출돼서 해당 항목의 설명으로 제공된다.
이거를 잘 적어줘야 한다.

위에서 설명했듯 보통 패키지 주석은 블록주석을 쓰지만, 짧으면 걍 한줄수석 써도 괜찮음.

주석에서도 space나 정렬은 사용하지 않는것이 좋고, HTML이나 `_this_`것도 그대로 나타나므로 사용하지 않는게 좋다.

주석은 최대한 정확하고 설명을 보기좋게 적어줘야 한다.

> **주석은 선언 이름으로 시작하고, 다양한 표현을 갖는 완전한 문장으로 작성해주는것이 좋다!!**

위의 장점은

1. 해당 메서드를 찾기 위해 검색할 때에 찾기 쉽다.
2. 해당 메서드를 찾은 후, 이게 이름이 뭔지는 주석 맨 앞의 시작부를 보면 알 수 있다.

## Names(명칭)

Go에서는 이름따라서 전역 지역여부가 결정됨

### 패키지명

패키지는 관례적으로 `소문자`, `한단어`를 사용한다 (즉 언더바나 카멜케이스로 이름을 나타내는경우는 없도록 한다).
그 이유는 사용자가 직접 패키지를 타이핑해서 써야하는데 이때 간결해야 좋기 때문이다.

패키지명은 오직 import를 위해서 사용된다.
모든 소스코드에서 유일할 필요는 없으며 혹시나 패키지가 충돌될 때에는 다른 이름 선택 가능.

그리고 패키지명은 소스 디렉토리 이름 기반이다.

> 근데 궁금한게 있는데 이거 패키지명을 이렇게 쓰는 이유가 뭘까?
> java에서처럼 그냥 DI를 통해 이름 그대로 가져오면 각각이 쓰이기도 쉽고 스펙 변경이 있을 때에 바로 적용 가능할것같은데??
> 패키지 위치가 바뀌는 경우는?

-> 인터페이스를 통해 가능하다고 한다...

### Getter

Getter/Setter를 자체적으로 제공하지 않는다.
알아서 만들어 써도 되긴 하는데 굳이? Go답지 않게? 그럴필요가 없다.
그냥 대문자로 어디서나 불릴수 있는 메소드 선언 후에 hook을 써서 쓰자.

> 근데 이거는 Getter/Setter를 쓰지 않는다면 그냥 하나로 다쓰는건가??

### 인터페이스명

하나의 메서드를 갖는 인터페이스는 관례적으로 이름에 `er`를 붙이거나 이런 비슷한 이름을 갖는다.
그리고 이미 있는거랑 같은 용법과 의미를 가지고 있으면 그걸 쓰고, 아니면 같은이름은 쓰지 말자.

### 대소문자 혼합

Camel Case 쓴다.

## Semicolons(세미콜론)

세미콜론은 잘 안쓰인다.
보통은 `구문을 끝낼 수 있는 토큰 뒤에 새로운 라인이 오면 세미콜론을 삽입한다.` 이다.
그래서 이것도

이러면 되는데

```
if i < f() {
    g()
}
```

이러면 안된다.

```
if i < f()  // wrong!
{           // wrong!
    g()
}
```

* 컨벤션이 유지되어서 좋을듯!
* 세미콜론은 이렇게 자주 쓰이는 문법에 안쓰여서 좋음
    * 이거 그리고 세미콜론 위치도 사람마다 달라서 컨벤션 깨질수있어

## Function(함수)

### Multiple return values(다중반환값)

Go는 함수와 메소드가 여러 값을 반환할 수 있다.
이렇게 하면 C에서처럼 `EOF는 -1` 요런 식으로 안하고 그냥 err를 내보낼수 있다.

> Go에서는 err를 처리하는 여러 방식이 있다는데, 이것에 대해서도 알아보는게 좋을 듯 싶다.

### Named result parameters(이름있는 결과 인자값)

Go에서 아예 반환용 인자에 이름을 부여하고 이거를 일반 변수처럼 사용할 수 있다.
굳이 이름을 부여할 필요는 없지만 코드가 더 짧고 명확해진다.

* 어떤 변수가 return되는지 알 수 있으므로 결과를 명확히 알 수 있다.
* 최초에 인자에 값이 할당되므로 코드가 줄여짐
* 원하는 결과를 함수 내에서 변경하는 경우, 따로 값을 줄 필요 없이 그냥 return하면 된다.
    * 이러면 코드도 짧아지고 변화를 디버깅 과정에서 빠르게 확인할 수 있다는 장점이 있지 싶다!

### Defer

Go의 `defer`문은 이걸 실행하는 함수가 반환되기 전에 즉각적으로 함수를 실행하도록 예약한다.
이걸 통해 반환을 하거나 자원을 해지하는 경우 사용 가능하다.

주로 뮤텍스의 잠금을 풀거나 파일을 닫는 것이 있다.

이걸 써서 얻는 장점

* Close같은 함수를 지연시켜서
    * 파일 닫는거를 잊어버리지 않을 수 있음
    * open하고 뒤에 defer close하면 굉장히 보기좋음

Defer함수는 LIFO순서로 실행된다.

## Methods(메소드)

메서드는 포인터와 인터페이스를 제외한 모든 타입에 대해 정의가 가능하다.
리시버는 꼭 구조체일 필요는 없다.

## control_structures(제어 구조)

C랑 비슷한데 큰 차이가 있다.
여기는 `do ~ while`문이 없으며 `for`, `switch`가 있다.

`if`랑 `switch`는 선택적으로 `for`같은 초기화 구문을 받을 수 있다.

### if

의무적으로 중괄호를 써야함.
다중 라인에서 if구문이 간단하게 작성되고, 그게 좋은 스타일이다.
특히 if문 내부에 return이나 break같은게 포함되면 더욱더 그러함

그리고 if문 뒤로 가지 않는경우 else는 생략된다.

### 재선언과 재할당

`:=`

이거를 쓰면 재선언이 가능함!
이렇게 매번 재선언해서 써줄때 `if-else`에서 에러를 쉽게 사용해줄수 있다.

### For

이걸로 while처럼 동작시킬수도 있음. -> 그래서 go에서는 do~while이 따로 없다.

### Switch

switch안에는 별거 다넣을수 있더라
그리고 if-else-if-else 이것보다는 switch를 쓰도록 합시다.

## Data

* Go의 메모리 할당 두가지 기본 방식
    * new
    * make

### New를 사용하는 메모리 할당

new는 포인터를 반환한다.

C언어랑은 다르게 Go에서 new를 통해 반환하면 쓰레기 값 없이 0을 반환해서 초기화를 해줄필요가 없다.

syncedBuffer -> mutex(lock) + buffer(Buffer)

mutex랑 buffer는 제로값을 바로 사용할수 있는 친구들이다.
그래서 new처럼 zero로 일단 초기화 해주면 사용 가능

> 요약하자면 new는 그냥 메모리를 할당할 때에 바로 값까지 초기화해주는 친구
> 그리고 결과로 객체의 주소(*T)를 반환해준다. <- 포인터

### make를 사용하는 메모리 할당

make는 초기화된 값을 반환한다.

얘는 `slices`, `maps`, `channels`에만 사용한다.
왜일까?

* slices
    * go의 동적 배열타입(참조타입)
* maps
    * go의 k-v hash table(참조타입)
* channels
    * message queue역할을 한다(참조타입)


참조 타입(reference type)으로 다른 값을 확인하는 것이다.
이들은 동적으로 구성되는데, 다른 정적 타입들과 다르게 크기가 미리 지정되지 않아 컴퓨터가 어디서부터 어디까지 값을 채워야하는지 모른다.

> 요약하자면 컴퓨터에서 이걸 위해 얼마만큼의 메모리가 필요할지 모르면 nil로 선언하니까, make를 통해 할당해주어야 하는 양을 정해준다.
> 그리고 결과로 객체의 값을 반환한다. 따라서 포인트가 필요하면 new를 사용해주거나 명시적으로 주소를 가져가면 된다.

### 배열

* 값 타입
    * A배열을 B배열에 할당할 때에 A배을의 모든 요소가 복사됨
    * 함수에 배열을 패스할 때에 포인터가 아니라 `복사된`배열을 받음
    * 배열의 크기는 타입의 한 부분이다.

매번 값을 사용하면 비용이 클수 있다.
그래서 포인터를 써도 되긴 하는데, 그럴거면 그냥 slice를 쓰자

### slice

어지간하면 slice를 쓴다.

* 참조타입
    * 내부 배열을 가리키는 포인터 형식
    * 다른 slice에 배열이 할당되어도 `동일한`배열을 가리킨다.

make를 써서

`make([T], len, cap) []T`

* T
    * 요소 타입
* len
    * 길이
* cap
    * 용량

요렇게 해주면 된다.

slice는 그리고 나중에 반환시켜야 한다.

> GC에서 이거를 처리하는 방법을 찾아보면 알 수 있는데, 다른곳에서 사용되고 있는 경우 전체가 참조되어서 안쓰는 부분도 GC대상이 아닐수 있기 때문.

### Maps

key는 equality연산이 정의돼있는건 어떤 타입이든 가능하다. -> (==, !=)

