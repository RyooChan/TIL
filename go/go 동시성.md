# Go Concurrency

* 일단 go에서 공유 변수는 개별 쓰레드 실행에 의해 공유되지 않는다.
    * 즉, 하나의 고루틴만 하나의 값에 접근한다는 것이다.

따로 찾아보니 go의 runtime중에 스케줄링하여 사용하는것이 고루틴이라고 한다.
즉 OS에 의해 스케쥴링되는것이 아니라 go에서 자체적으로 스케쥴링하는것이다.
-> 이 때문에 기존 process나 thread에 비해 가볍다. 내부에서 그때그때 꺼내쓰면 되거든

## 고루틴

> 같은 주소 공간에서 다른 고루틴과 동시에 실행되는 함수

* 가볍다
* 힙 스토리지 할당
    * 스택 영역 할당에 비해 비용이 적다.

다중 쓰레드에 멀티플렉싱되어 하나의 고루틴이 블락되면 다른 고루틴이 실행된다.
함수가 참조하는 변수를 사용하는 동안에는 생존 보장.

## 채널

> 고루틴간 데이터를 전달하는 통로 역할을 한다.
> 얘는 변수의 역할을 할수는 없다.

채널을 통해 고루틴간의 데이터 동기화가 가능하다.

버퍼가 없는(언버퍼드)채널은 동기화로 값을 교환하며 고루틴들이 어떤 상태에 있는지 보장하는 통신을 결합
-> synchronized처럼 어떤 고루틴이 값에 접근시 다른 곳에서의 접근을 아예 lock을 거는 느낌?

* 수신부는 항상 수신한 데이터가 있을때까지 블락
* 송신부
    * 언버퍼드면 수신부가 값을 받을 때까지 블락됨
    * 버퍼드면 값이 버퍼에 복사될 때까지만 송신부 블락

버퍼드 채널은 semaphore처럼 사용될 수 있다.(쓰레드 임계계수를 정해두고 그 이상은 막는 느낌)
버퍼의 크기가 동시 처리 가능 숫자를 정해준다.

* 문제점은
    * 정해진 크기가 있는데, 서버에서는 요청이 올때마다 고루틴 생성
    * 그러면 다 처리되기 전에 새로운 고루틴 요청이 올 시에는 리소스가 계속해서 낭비될 수 있음.

해결법은 일단 여러 가지가 제안되었는데 가장 go같은것으로는 같은 이름의 새로운 변수를 필요한 만큼 새로 생성해서 process에 넣어주는 것이다.

`req := req`

이런 식인데, 깊은 복사를 진행하여 하나의 변수를 가지고 각각의 고루틴마다 다른 변수를 보내주는것

