# 인프런 스터디 1
###### tags: `Tag(인프런)`

## 자바 ORM표준 JPA프로그래밍 - 기본편
### JPA란
* 과거에는 SQL을 하나씩 작성하던 것을 JPA가 나타난 후부터는 코드로 작성할 수 있게 해 주었다.
    * 그럼 JPA가 그에 맞는 sql을 실행해 준다.
* 속도, 생산성과 유지보수 등에서 훨씬 빨라졌다.
* 다만 난이도가 어렵다.
    * 실무에서는 JPA를 사용하면 굉장히 어렵다.
        * JPA는 다른 것들에 비해 객체와 테이블을 잘 설계하고 매핑을 해야 한다.
    * JPA의 내부 동작 방식을 모르고 쓰는 경우가 많다.
        * JPA가 어떤 SQL을 만들어 내고, 언제 실행하는지 이해해야 한다.



### 기존 SQL을 사용하는 문제점
개발 언어는 주로 객체지향 언어이다 + DB는 주로 RDB(관계형 DB)를 사용한다
=> 즉, 객체를 관계형 DB에 관리한다.

#### SQL중심적인 코딩의 문제점
* 일단 지루함.
* 코드 완성 후 변경사항이 있을 경우 너무 많은 장소에서 변경해야 한다.
    * 예를 들어 name, email만을 작성했는데, phone을 추가하면 이게 필요한 모든 곳에서 추가해줘야 한다.

#### 객체지향 vs 관계형DB의 패러다임 불일치
* 객체지향
    * 필드/메소드 등을 잘 캡슐화 하여 사용하려는 목적이다.
* 관계형DB
    * 데이터를 잘 정규화 하여 보관하려는 목적이다.
1. 상속

![](https://i.imgur.com/Xrpo0tf.png)

객체에서 단순히 상속받아서 저장하면 되는 일을, 관계형 DB에서는 너무 복잡하게 처리해야 한다.
이를 java에서 처리하면 쉽게 할 수 있을 것이다.

2. 연관관계

![](https://i.imgur.com/DxedTDh.png)

여기서 보면 알 수 있는 것이 객체 연관관계에서
Member -> Team은 갈 수 있는데 반대로
Team -> Member로는 갈 수 없다.

테이블 연관관계에서는 이게 양방향이 가능하다.

3. 엔티티 신뢰 문제

![](https://i.imgur.com/8ZeGP7f.png)

여기서 만약에 

```
SELECT M.*, T.m*
FROM MEMBER X
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
```

라는 SQL을 실행하면 MEMBER와 TEAM에 해당하는 값들이 구해진다.
여기서 만약에

member.getTeam() 을 하면 team의 정보는 얻어올 수 있지만
member.getOrder()을 하면 order의 정보를 얻어올 수 없다.

그렇다고 매번 member를 다 가져올 수도 없다...

-> JPA를 사용하면 객체를 자바 컬렉션에 저장 하듯이 DB에 저장할 수 있도록 해 준다.

종합하자면 객체지향 언어와 관점지향DB간의 불일치의 해결과 생산성 등을 위해 도입된 것이 JPA이다.

---

### JPA의 개념
* Java Persistence API
* 자바 진영 ORM기술의 표준이다.
    * ORM이란 Object-relational mapping(객체 관계 매핑) -> 참고로 여기서 relational이 관계형 DB의 그 R이다.
    * 객체는 객체대로, 관계형DB는 관계형대로 설계하여 ORM프레임워크가 이를 중간에서 매핑시켜 주는 역할을 한다.
        * 각자 알아서 개발을 하면 ORM이 알아서 매핑을 해주겠다는 것.
* 어플리케이션 - JDBC사이에서 동작한다.
    * 패러다임 불일치를 여기서 해결해 준다.

### JPA사용의 이유
- SQL 중심적 개발이 아닌, 객체 중심 개발을 할 수 있다.
- 생산성이 높다.
    - 코드가 이미 만들어져 있어서 이를 불러서 쓰면 되니까 생산성이 당연히 높다.
- 유지보수가 편하다
    - 필드의 변경 등이 있을 때 SQL을 하나하나 변경할 필요가 없다.
- **패러다임의 불일치 해결**
    - 상속, 연관관계, 객체 그래프 탐색, 비교의 해결
- 성능 최적화
    - 1차 캐시와 동일성 보장
        - 같은 트랜잭션 내에서는 같은 엔티티를 반환한다.
            - 이를 통해 약간의 조회 성능 향상
                - 똑같은 SQL이 실행되면 캐시된 메모리를 그대로 반환시킨다.
                    - 2번 같은걸 부르면 SQL을 1번만 실행하기.
    - 트랜잭션을 지원하는 쓰기 지연 - INSERT
        - 트랜잭션의 begin ~ commit사이에서 사용한 INSERT를 하나하나 진행하지 않고, 한꺼번에 뭉탱이로 처리한다.
            - commit하는 순간 한꺼번에 네트워크를 통해 INSERT처리하기
                - 이는 본래 JDBC batch를 사용하는 기능인데, 이게 코드가 엄청 지저분해 진다.
                    - 이 지저분한 것을 JPA에서 한번에 가능하게 해 준다.
    - 지연로딩 / 즉시로딩(eager, lazy)
        - Lazy방식
            - 객체가 실제 사용될 때 로딩한다.
        - Eager방식
            - Join을 사용하여 한번에 연관된 객체까지 미리 조회한다.
- 데이터 접근 추상화와 벤더 독립성
- 표준

---

