## API 뽑아내기

### 엔티티 조회
1. 엔티티를 조회해서 그대로 반환 -> 사용하면 안됨
2. 엔티티 조회 후 DTO로 변환
3. 페치 조인으로 쿼리 수 최적화 -> (2)에서 성능이 나오지 않을때 추가해주면 된다.
    * 컬렉션에서 페치 조인을 사용하는 경우 페이징을 사용하지 못하는 경우가 생긴다.
        * 그럴 때에는 이전에 배운 한계돌파를 사용한다.

### DTO 직접 조회
1. JPA에서 DTO를 직접 조회
2. 컬렉션 조회 최적화
    * 일대다 관계인 컬렉션은 IN절을 활용해서 메모리에 미리 조회해서 최적화한다.
        * 먼저 일에 해당하는 애들을 싹다 가져오고, 이후 다에 해당하는 부분을 IN절에서 로딩해서 가져온다.
3. 플랫 데이터 최적화
    * JOIN결과를 그대로 모두 가져와서 애플리케이션에서 원하는 모양으로 변환한다.
        * 중복 데이터 전체 들고온 후 애플리케이션에서 최적화 진행.

처음 방식은 코드가 단순하고 유지보수가 단순하다.
그리고 특정 주문 한건만 조회하면 이 방식으로도 성능이 잘 나온다.

컬렉션 조회 최적화는 코드가 복잡하다.
위의 방식에서의 문제점은 N+1을 1+1로 해결 가능하다.

플랫데이터 위와는 전혀 다른 접근방식이다.
한번에 모든 데이터를 패치해서 뻥튀기된 데이터를 들고와서 어플리케이션에서 이를 최적화한다.
이는 보통 위의 방식보다 성능이 좋지만, 어플리케이션에 부하가 생길 수 있으며 중복 데이터가 들어는 등의 단점을 가진다.
다만, 실무에서는 이정도로 최적화가 필요한 데이터는 최소 수백, 수천건이 필요한데 페이징이 불가능하다면...조금 선택하기 어려운 방법이라 한다.
또 위의 컬렉션 조회와 비교할 때에도 데이터의 전송이 많기 때문에 중복 전송이 증가하여 성능이 막 많이 증가하는 부분도 없다고 한다.

### 권장 순서
1. 엔티티 조회 방식으로 우선 접근한다.
    1-1. 페치조인으로 쿼리수 최적화하기.
    1-2. 컬렉션 최적화(페이징 유무에 따라)
2. 엔티티 조회 방식으로 해결이 안되면 DTO조회 방식 사용하기
3. 이 DTO방식으로도 안되면 NativeSQL이나 Spring JdbcTemplate사용하기

엔티티 조회 방식은 페치 조인이나, hibernate.default_batch_fetch_size를 바로 사용할수 있다.
이런 것들을 사용하면, 코드의 수정을 최소화한 상태로 옵션만 약간 변경해서 다양한 성능 최적화를 시도할 수 있다.

반면에 DTO를 직접 조회하게 되면 성능 최적화를 진행하거나, 성능 최적화 방법을 변경할 때에 많은 코드 변경을 요구한다.

참고로...DTO로 변경해서 뽑아오는 방식은 잘 사용하지는 않는다. 진짜 사람이 엄청나게 많지 않은경우에는 안쓰기 때문이다.
그리고 DTO를 사용하면 캐싱을 사용해서 적용한다. 이렇게 하면 성능 향상을 더 해줄 수 있기 때문이다. **엔티티의 경우는 캐시 사용을 해서는 안된다**!!

---
